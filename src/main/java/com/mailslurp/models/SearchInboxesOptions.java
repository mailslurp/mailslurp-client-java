/*
 * MailSlurp API
 * MailSlurp is an API for sending and receiving emails and SMS from dynamically allocated email addresses and phone numbers. It's designed for developers and QA teams to test applications, process inbound emails, send templated notifications, attachments, and more.  ## Resources  - [Homepage](https://www.mailslurp.com) - Get an [API KEY](https://app.mailslurp.com/sign-up/) - Generated [SDK Clients](https://docs.mailslurp.com/) - [Examples](https://github.com/mailslurp/examples) repository
 *
 * The version of the OpenAPI document: 6.5.2
 * Contact: contact@mailslurp.dev
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


package com.mailslurp.models;

import java.util.Objects;
import com.google.gson.TypeAdapter;
import com.google.gson.annotations.JsonAdapter;
import com.google.gson.annotations.SerializedName;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;
import java.time.OffsetDateTime;
import java.util.Arrays;
import java.util.UUID;
import org.openapitools.jackson.nullable.JsonNullable;

import com.google.gson.Gson;
import com.google.gson.GsonBuilder;
import com.google.gson.JsonArray;
import com.google.gson.JsonDeserializationContext;
import com.google.gson.JsonDeserializer;
import com.google.gson.JsonElement;
import com.google.gson.JsonObject;
import com.google.gson.JsonParseException;
import com.google.gson.TypeAdapterFactory;
import com.google.gson.reflect.TypeToken;
import com.google.gson.TypeAdapter;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;

import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;

import com.mailslurp.clients.JSON;

/**
 * SearchInboxesOptions
 */
@javax.annotation.Generated(value = "org.openapitools.codegen.languages.JavaClientCodegen", date = "2025-07-30T22:25:17.446308831Z[Etc/UTC]", comments = "Generator version: 7.13.0")
public class SearchInboxesOptions {
  public static final String SERIALIZED_NAME_PAGE_INDEX = "pageIndex";
  @SerializedName(SERIALIZED_NAME_PAGE_INDEX)
  @javax.annotation.Nullable
  private Integer pageIndex;

  public static final String SERIALIZED_NAME_PAGE_SIZE = "pageSize";
  @SerializedName(SERIALIZED_NAME_PAGE_SIZE)
  @javax.annotation.Nullable
  private Integer pageSize;

  /**
   * Optional createdAt sort direction ASC or DESC
   */
  @JsonAdapter(SortDirectionEnum.Adapter.class)
  public enum SortDirectionEnum {
    ASC("ASC"),
    
    DESC("DESC");

    private String value;

    SortDirectionEnum(String value) {
      this.value = value;
    }

    public String getValue() {
      return value;
    }

    @Override
    public String toString() {
      return String.valueOf(value);
    }

    public static SortDirectionEnum fromValue(String value) {
      for (SortDirectionEnum b : SortDirectionEnum.values()) {
        if (b.value.equals(value)) {
          return b;
        }
      }
      return null;
    }

    public static class Adapter extends TypeAdapter<SortDirectionEnum> {
      @Override
      public void write(final JsonWriter jsonWriter, final SortDirectionEnum enumeration) throws IOException {
        jsonWriter.value(enumeration.getValue());
      }

      @Override
      public SortDirectionEnum read(final JsonReader jsonReader) throws IOException {
        String value =  jsonReader.nextString();
        return SortDirectionEnum.fromValue(value);
      }
    }

    public static void validateJsonElement(JsonElement jsonElement) throws IOException { if (true) { return; }
      String value = jsonElement.getAsString();
      SortDirectionEnum.fromValue(value);
    }
  }

  public static final String SERIALIZED_NAME_SORT_DIRECTION = "sortDirection";
  @SerializedName(SERIALIZED_NAME_SORT_DIRECTION)
  @javax.annotation.Nullable
  private SortDirectionEnum sortDirection;

  public static final String SERIALIZED_NAME_FAVOURITE = "favourite";
  @SerializedName(SERIALIZED_NAME_FAVOURITE)
  @javax.annotation.Nullable
  private Boolean favourite;

  public static final String SERIALIZED_NAME_SEARCH = "search";
  @SerializedName(SERIALIZED_NAME_SEARCH)
  @javax.annotation.Nullable
  private String search;

  public static final String SERIALIZED_NAME_TAG = "tag";
  @SerializedName(SERIALIZED_NAME_TAG)
  @javax.annotation.Nullable
  private String tag;

  public static final String SERIALIZED_NAME_SINCE = "since";
  @SerializedName(SERIALIZED_NAME_SINCE)
  @javax.annotation.Nullable
  private OffsetDateTime since;

  public static final String SERIALIZED_NAME_BEFORE = "before";
  @SerializedName(SERIALIZED_NAME_BEFORE)
  @javax.annotation.Nullable
  private OffsetDateTime before;

  /**
   * Type of inbox. HTTP inboxes are faster and better for most cases. SMTP inboxes are more suited for public facing inbound messages (but cannot send).
   */
  @JsonAdapter(InboxTypeEnum.Adapter.class)
  public enum InboxTypeEnum {
    HTTP_INBOX("HTTP_INBOX"),
    
    SMTP_INBOX("SMTP_INBOX");

    private String value;

    InboxTypeEnum(String value) {
      this.value = value;
    }

    public String getValue() {
      return value;
    }

    @Override
    public String toString() {
      return String.valueOf(value);
    }

    public static InboxTypeEnum fromValue(String value) {
      for (InboxTypeEnum b : InboxTypeEnum.values()) {
        if (b.value.equals(value)) {
          return b;
        }
      }
      return null;
    }

    public static class Adapter extends TypeAdapter<InboxTypeEnum> {
      @Override
      public void write(final JsonWriter jsonWriter, final InboxTypeEnum enumeration) throws IOException {
        jsonWriter.value(enumeration.getValue());
      }

      @Override
      public InboxTypeEnum read(final JsonReader jsonReader) throws IOException {
        String value =  jsonReader.nextString();
        return InboxTypeEnum.fromValue(value);
      }
    }

    public static void validateJsonElement(JsonElement jsonElement) throws IOException { if (true) { return; }
      String value = jsonElement.getAsString();
      InboxTypeEnum.fromValue(value);
    }
  }

  public static final String SERIALIZED_NAME_INBOX_TYPE = "inboxType";
  @SerializedName(SERIALIZED_NAME_INBOX_TYPE)
  @javax.annotation.Nullable
  private InboxTypeEnum inboxType;

  /**
   * Optional filter by inbox function
   */
  @JsonAdapter(InboxFunctionEnum.Adapter.class)
  public enum InboxFunctionEnum {
    ALIAS("ALIAS"),
    
    THREAD("THREAD"),
    
    CATCH_ALL("CATCH_ALL"),
    
    CONNECTOR("CONNECTOR"),
    
    ACCOUNT("ACCOUNT"),
    
    GUEST("GUEST"),
    
    OAUTH_CONNECTION_GMAIL("OAUTH_CONNECTION_GMAIL");

    private String value;

    InboxFunctionEnum(String value) {
      this.value = value;
    }

    public String getValue() {
      return value;
    }

    @Override
    public String toString() {
      return String.valueOf(value);
    }

    public static InboxFunctionEnum fromValue(String value) {
      for (InboxFunctionEnum b : InboxFunctionEnum.values()) {
        if (b.value.equals(value)) {
          return b;
        }
      }
      return null;
    }

    public static class Adapter extends TypeAdapter<InboxFunctionEnum> {
      @Override
      public void write(final JsonWriter jsonWriter, final InboxFunctionEnum enumeration) throws IOException {
        jsonWriter.value(enumeration.getValue());
      }

      @Override
      public InboxFunctionEnum read(final JsonReader jsonReader) throws IOException {
        String value =  jsonReader.nextString();
        return InboxFunctionEnum.fromValue(value);
      }
    }

    public static void validateJsonElement(JsonElement jsonElement) throws IOException { if (true) { return; }
      String value = jsonElement.getAsString();
      InboxFunctionEnum.fromValue(value);
    }
  }

  public static final String SERIALIZED_NAME_INBOX_FUNCTION = "inboxFunction";
  @SerializedName(SERIALIZED_NAME_INBOX_FUNCTION)
  @javax.annotation.Nullable
  private InboxFunctionEnum inboxFunction;

  public static final String SERIALIZED_NAME_DOMAIN_ID = "domainId";
  @SerializedName(SERIALIZED_NAME_DOMAIN_ID)
  @javax.annotation.Nullable
  private UUID domainId;

  public SearchInboxesOptions() {
  }

  public SearchInboxesOptions pageIndex(@javax.annotation.Nullable Integer pageIndex) {
    this.pageIndex = pageIndex;
    return this;
  }

  /**
   * Optional page index in list pagination
   * @return pageIndex
   */
  @javax.annotation.Nullable
  public Integer getPageIndex() {
    return pageIndex;
  }

  public void setPageIndex(@javax.annotation.Nullable Integer pageIndex) {
    this.pageIndex = pageIndex;
  }


  public SearchInboxesOptions pageSize(@javax.annotation.Nullable Integer pageSize) {
    this.pageSize = pageSize;
    return this;
  }

  /**
   * Optional page size in list pagination
   * @return pageSize
   */
  @javax.annotation.Nullable
  public Integer getPageSize() {
    return pageSize;
  }

  public void setPageSize(@javax.annotation.Nullable Integer pageSize) {
    this.pageSize = pageSize;
  }


  public SearchInboxesOptions sortDirection(@javax.annotation.Nullable SortDirectionEnum sortDirection) {
    this.sortDirection = sortDirection;
    return this;
  }

  /**
   * Optional createdAt sort direction ASC or DESC
   * @return sortDirection
   */
  @javax.annotation.Nullable
  public SortDirectionEnum getSortDirection() {
    return sortDirection;
  }

  public void setSortDirection(@javax.annotation.Nullable SortDirectionEnum sortDirection) {
    this.sortDirection = sortDirection;
  }


  public SearchInboxesOptions favourite(@javax.annotation.Nullable Boolean favourite) {
    this.favourite = favourite;
    return this;
  }

  /**
   * Optionally filter results for favourites only
   * @return favourite
   */
  @javax.annotation.Nullable
  public Boolean getFavourite() {
    return favourite;
  }

  public void setFavourite(@javax.annotation.Nullable Boolean favourite) {
    this.favourite = favourite;
  }


  public SearchInboxesOptions search(@javax.annotation.Nullable String search) {
    this.search = search;
    return this;
  }

  /**
   * Optionally filter by search words partial matching ID, tags, name, and email address
   * @return search
   */
  @javax.annotation.Nullable
  public String getSearch() {
    return search;
  }

  public void setSearch(@javax.annotation.Nullable String search) {
    this.search = search;
  }


  public SearchInboxesOptions tag(@javax.annotation.Nullable String tag) {
    this.tag = tag;
    return this;
  }

  /**
   * Optionally filter by tags. Will return inboxes that include given tags
   * @return tag
   */
  @javax.annotation.Nullable
  public String getTag() {
    return tag;
  }

  public void setTag(@javax.annotation.Nullable String tag) {
    this.tag = tag;
  }


  public SearchInboxesOptions since(@javax.annotation.Nullable OffsetDateTime since) {
    this.since = since;
    return this;
  }

  /**
   * Optional filter by created after given date time
   * @return since
   */
  @javax.annotation.Nullable
  public OffsetDateTime getSince() {
    return since;
  }

  public void setSince(@javax.annotation.Nullable OffsetDateTime since) {
    this.since = since;
  }


  public SearchInboxesOptions before(@javax.annotation.Nullable OffsetDateTime before) {
    this.before = before;
    return this;
  }

  /**
   * Optional filter by created before given date time
   * @return before
   */
  @javax.annotation.Nullable
  public OffsetDateTime getBefore() {
    return before;
  }

  public void setBefore(@javax.annotation.Nullable OffsetDateTime before) {
    this.before = before;
  }


  public SearchInboxesOptions inboxType(@javax.annotation.Nullable InboxTypeEnum inboxType) {
    this.inboxType = inboxType;
    return this;
  }

  /**
   * Type of inbox. HTTP inboxes are faster and better for most cases. SMTP inboxes are more suited for public facing inbound messages (but cannot send).
   * @return inboxType
   */
  @javax.annotation.Nullable
  public InboxTypeEnum getInboxType() {
    return inboxType;
  }

  public void setInboxType(@javax.annotation.Nullable InboxTypeEnum inboxType) {
    this.inboxType = inboxType;
  }


  public SearchInboxesOptions inboxFunction(@javax.annotation.Nullable InboxFunctionEnum inboxFunction) {
    this.inboxFunction = inboxFunction;
    return this;
  }

  /**
   * Optional filter by inbox function
   * @return inboxFunction
   */
  @javax.annotation.Nullable
  public InboxFunctionEnum getInboxFunction() {
    return inboxFunction;
  }

  public void setInboxFunction(@javax.annotation.Nullable InboxFunctionEnum inboxFunction) {
    this.inboxFunction = inboxFunction;
  }


  public SearchInboxesOptions domainId(@javax.annotation.Nullable UUID domainId) {
    this.domainId = domainId;
    return this;
  }

  /**
   * Optional domain ID filter
   * @return domainId
   */
  @javax.annotation.Nullable
  public UUID getDomainId() {
    return domainId;
  }

  public void setDomainId(@javax.annotation.Nullable UUID domainId) {
    this.domainId = domainId;
  }



  @Override
  public boolean equals(Object o) {
    if (this == o) {
      return true;
    }
    if (o == null || getClass() != o.getClass()) {
      return false;
    }
    SearchInboxesOptions searchInboxesOptions = (SearchInboxesOptions) o;
    return Objects.equals(this.pageIndex, searchInboxesOptions.pageIndex) &&
        Objects.equals(this.pageSize, searchInboxesOptions.pageSize) &&
        Objects.equals(this.sortDirection, searchInboxesOptions.sortDirection) &&
        Objects.equals(this.favourite, searchInboxesOptions.favourite) &&
        Objects.equals(this.search, searchInboxesOptions.search) &&
        Objects.equals(this.tag, searchInboxesOptions.tag) &&
        Objects.equals(this.since, searchInboxesOptions.since) &&
        Objects.equals(this.before, searchInboxesOptions.before) &&
        Objects.equals(this.inboxType, searchInboxesOptions.inboxType) &&
        Objects.equals(this.inboxFunction, searchInboxesOptions.inboxFunction) &&
        Objects.equals(this.domainId, searchInboxesOptions.domainId);
  }

  private static <T> boolean equalsNullable(JsonNullable<T> a, JsonNullable<T> b) {
    return a == b || (a != null && b != null && a.isPresent() && b.isPresent() && Objects.deepEquals(a.get(), b.get()));
  }

  @Override
  public int hashCode() {
    return Objects.hash(pageIndex, pageSize, sortDirection, favourite, search, tag, since, before, inboxType, inboxFunction, domainId);
  }

  private static <T> int hashCodeNullable(JsonNullable<T> a) {
    if (a == null) {
      return 1;
    }
    return a.isPresent() ? Arrays.deepHashCode(new Object[]{a.get()}) : 31;
  }

  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append("class SearchInboxesOptions {\n");
    sb.append("    pageIndex: ").append(toIndentedString(pageIndex)).append("\n");
    sb.append("    pageSize: ").append(toIndentedString(pageSize)).append("\n");
    sb.append("    sortDirection: ").append(toIndentedString(sortDirection)).append("\n");
    sb.append("    favourite: ").append(toIndentedString(favourite)).append("\n");
    sb.append("    search: ").append(toIndentedString(search)).append("\n");
    sb.append("    tag: ").append(toIndentedString(tag)).append("\n");
    sb.append("    since: ").append(toIndentedString(since)).append("\n");
    sb.append("    before: ").append(toIndentedString(before)).append("\n");
    sb.append("    inboxType: ").append(toIndentedString(inboxType)).append("\n");
    sb.append("    inboxFunction: ").append(toIndentedString(inboxFunction)).append("\n");
    sb.append("    domainId: ").append(toIndentedString(domainId)).append("\n");
    sb.append("}");
    return sb.toString();
  }

  /**
   * Convert the given object to string with each line indented by 4 spaces
   * (except the first line).
   */
  private String toIndentedString(Object o) {
    if (o == null) {
      return "null";
    }
    return o.toString().replace("\n", "\n    ");
  }


  public static HashSet<String> openapiFields;
  public static HashSet<String> openapiRequiredFields;

  static {
    // a set of all properties/fields (JSON key names)
    openapiFields = new HashSet<String>();
    openapiFields.add("pageIndex");
    openapiFields.add("pageSize");
    openapiFields.add("sortDirection");
    openapiFields.add("favourite");
    openapiFields.add("search");
    openapiFields.add("tag");
    openapiFields.add("since");
    openapiFields.add("before");
    openapiFields.add("inboxType");
    openapiFields.add("inboxFunction");
    openapiFields.add("domainId");

    // a set of required properties/fields (JSON key names)
    openapiRequiredFields = new HashSet<String>();
  }

  /**
   * Validates the JSON Element and throws an exception if issues found
   *
   * @param jsonElement JSON Element
   * @throws IOException if the JSON Element is invalid with respect to SearchInboxesOptions
   */
  public static void validateJsonElement(JsonElement jsonElement) throws IOException { if (true) { return; }
      if (jsonElement == null) {
        if (!SearchInboxesOptions.openapiRequiredFields.isEmpty()) { // has required fields but JSON element is null
          throw new IllegalArgumentException(String.format("The required field(s) %s in SearchInboxesOptions is not found in the empty JSON string", SearchInboxesOptions.openapiRequiredFields.toString()));
        }
      }

      Set<Map.Entry<String, JsonElement>> entries = jsonElement.getAsJsonObject().entrySet();
      // check to see if the JSON string contains additional fields
      for (Map.Entry<String, JsonElement> entry : entries) {
        if (!SearchInboxesOptions.openapiFields.contains(entry.getKey())) {
          throw new IllegalArgumentException(String.format("The field `%s` in the JSON string is not defined in the `SearchInboxesOptions` properties. JSON: %s", entry.getKey(), jsonElement.toString()));
        }
      }
        JsonObject jsonObj = jsonElement.getAsJsonObject();
      if ((jsonObj.get("sortDirection") != null && !jsonObj.get("sortDirection").isJsonNull()) && !jsonObj.get("sortDirection").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `sortDirection` to be a primitive type in the JSON string but got `%s`", jsonObj.get("sortDirection").toString()));
      }
      // validate the optional field `sortDirection`
      if (jsonObj.get("sortDirection") != null && !jsonObj.get("sortDirection").isJsonNull()) {
        SortDirectionEnum.validateJsonElement(jsonObj.get("sortDirection"));
      }
      if ((jsonObj.get("search") != null && !jsonObj.get("search").isJsonNull()) && !jsonObj.get("search").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `search` to be a primitive type in the JSON string but got `%s`", jsonObj.get("search").toString()));
      }
      if ((jsonObj.get("tag") != null && !jsonObj.get("tag").isJsonNull()) && !jsonObj.get("tag").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `tag` to be a primitive type in the JSON string but got `%s`", jsonObj.get("tag").toString()));
      }
      if ((jsonObj.get("inboxType") != null && !jsonObj.get("inboxType").isJsonNull()) && !jsonObj.get("inboxType").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `inboxType` to be a primitive type in the JSON string but got `%s`", jsonObj.get("inboxType").toString()));
      }
      // validate the optional field `inboxType`
      if (jsonObj.get("inboxType") != null && !jsonObj.get("inboxType").isJsonNull()) {
        InboxTypeEnum.validateJsonElement(jsonObj.get("inboxType"));
      }
      if ((jsonObj.get("inboxFunction") != null && !jsonObj.get("inboxFunction").isJsonNull()) && !jsonObj.get("inboxFunction").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `inboxFunction` to be a primitive type in the JSON string but got `%s`", jsonObj.get("inboxFunction").toString()));
      }
      // validate the optional field `inboxFunction`
      if (jsonObj.get("inboxFunction") != null && !jsonObj.get("inboxFunction").isJsonNull()) {
        InboxFunctionEnum.validateJsonElement(jsonObj.get("inboxFunction"));
      }
      if ((jsonObj.get("domainId") != null && !jsonObj.get("domainId").isJsonNull()) && !jsonObj.get("domainId").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `domainId` to be a primitive type in the JSON string but got `%s`", jsonObj.get("domainId").toString()));
      }
  }

  public static class CustomTypeAdapterFactory implements TypeAdapterFactory {
    @SuppressWarnings("unchecked")
    @Override
    public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> type) {
       if (!SearchInboxesOptions.class.isAssignableFrom(type.getRawType())) {
         return null; // this class only serializes 'SearchInboxesOptions' and its subtypes
       }
       final TypeAdapter<JsonElement> elementAdapter = gson.getAdapter(JsonElement.class);
       final TypeAdapter<SearchInboxesOptions> thisAdapter
                        = gson.getDelegateAdapter(this, TypeToken.get(SearchInboxesOptions.class));

       return (TypeAdapter<T>) new TypeAdapter<SearchInboxesOptions>() {
           @Override
           public void write(JsonWriter out, SearchInboxesOptions value) throws IOException {
             JsonObject obj = thisAdapter.toJsonTree(value).getAsJsonObject();
             elementAdapter.write(out, obj);
           }

           @Override
           public SearchInboxesOptions read(JsonReader in) throws IOException {
             JsonElement jsonElement = elementAdapter.read(in);
             validateJsonElement(jsonElement);
             return thisAdapter.fromJsonTree(jsonElement);
           }

       }.nullSafe();
    }
  }

  /**
   * Create an instance of SearchInboxesOptions given an JSON string
   *
   * @param jsonString JSON string
   * @return An instance of SearchInboxesOptions
   * @throws IOException if the JSON string is invalid with respect to SearchInboxesOptions
   */
  public static SearchInboxesOptions fromJson(String jsonString) throws IOException {
    return JSON.getGson().fromJson(jsonString, SearchInboxesOptions.class);
  }

  /**
   * Convert an instance of SearchInboxesOptions to an JSON string
   *
   * @return JSON string
   */
  public String toJson() {
    return JSON.getGson().toJson(this);
  }
}

