/*
 * MailSlurp API
 * MailSlurp is an API for sending and receiving emails and SMS from dynamically allocated email addresses and phone numbers. It's designed for developers and QA teams to test applications, process inbound emails, send templated notifications, attachments, and more.  ## Resources  - [Homepage](https://www.mailslurp.com) - Get an [API KEY](https://app.mailslurp.com/sign-up/) - Generated [SDK Clients](https://docs.mailslurp.com/) - [Examples](https://github.com/mailslurp/examples) repository
 *
 * The version of the OpenAPI document: 6.5.2
 * Contact: contact@mailslurp.dev
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


package com.mailslurp.models;

import java.util.Objects;
import com.google.gson.TypeAdapter;
import com.google.gson.annotations.JsonAdapter;
import com.google.gson.annotations.SerializedName;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;
import java.time.OffsetDateTime;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import org.openapitools.jackson.nullable.JsonNullable;

import com.google.gson.Gson;
import com.google.gson.GsonBuilder;
import com.google.gson.JsonArray;
import com.google.gson.JsonDeserializationContext;
import com.google.gson.JsonDeserializer;
import com.google.gson.JsonElement;
import com.google.gson.JsonObject;
import com.google.gson.JsonParseException;
import com.google.gson.TypeAdapterFactory;
import com.google.gson.reflect.TypeToken;
import com.google.gson.TypeAdapter;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;

import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;

import com.mailslurp.clients.JSON;

/**
 * IMAP server search options
 */
@javax.annotation.Generated(value = "org.openapitools.codegen.languages.JavaClientCodegen", date = "2025-07-30T22:25:17.446308831Z[Etc/UTC]", comments = "Generator version: 7.13.0")
public class ImapServerSearchOptions {
  public static final String SERIALIZED_NAME_SEQ_NUM = "seqNum";
  @SerializedName(SERIALIZED_NAME_SEQ_NUM)
  @javax.annotation.Nullable
  private String seqNum;

  public static final String SERIALIZED_NAME_UID = "uid";
  @SerializedName(SERIALIZED_NAME_UID)
  @javax.annotation.Nullable
  private String uid;

  public static final String SERIALIZED_NAME_SINCE = "since";
  @SerializedName(SERIALIZED_NAME_SINCE)
  @javax.annotation.Nullable
  private OffsetDateTime since;

  public static final String SERIALIZED_NAME_BEFORE = "before";
  @SerializedName(SERIALIZED_NAME_BEFORE)
  @javax.annotation.Nullable
  private OffsetDateTime before;

  public static final String SERIALIZED_NAME_SENT_SINCE = "sentSince";
  @SerializedName(SERIALIZED_NAME_SENT_SINCE)
  @javax.annotation.Nullable
  private OffsetDateTime sentSince;

  public static final String SERIALIZED_NAME_SENT_BEFORE = "sentBefore";
  @SerializedName(SERIALIZED_NAME_SENT_BEFORE)
  @javax.annotation.Nullable
  private OffsetDateTime sentBefore;

  public static final String SERIALIZED_NAME_HEADER = "header";
  @SerializedName(SERIALIZED_NAME_HEADER)
  @javax.annotation.Nullable
  private Map<String, List<String>> header;

  public static final String SERIALIZED_NAME_BODY = "body";
  @SerializedName(SERIALIZED_NAME_BODY)
  @javax.annotation.Nullable
  private List<String> body;

  public static final String SERIALIZED_NAME_TEXT = "text";
  @SerializedName(SERIALIZED_NAME_TEXT)
  @javax.annotation.Nullable
  private List<String> text;

  public static final String SERIALIZED_NAME_WITH_FLAGS = "withFlags";
  @SerializedName(SERIALIZED_NAME_WITH_FLAGS)
  @javax.annotation.Nullable
  private List<String> withFlags;

  public static final String SERIALIZED_NAME_WITHOUT_FLAGS = "withoutFlags";
  @SerializedName(SERIALIZED_NAME_WITHOUT_FLAGS)
  @javax.annotation.Nullable
  private List<String> withoutFlags;

  public ImapServerSearchOptions() {
  }

  public ImapServerSearchOptions seqNum(@javax.annotation.Nullable String seqNum) {
    this.seqNum = seqNum;
    return this;
  }

  /**
   * Get seqNum
   * @return seqNum
   */
  @javax.annotation.Nullable
  public String getSeqNum() {
    return seqNum;
  }

  public void setSeqNum(@javax.annotation.Nullable String seqNum) {
    this.seqNum = seqNum;
  }


  public ImapServerSearchOptions uid(@javax.annotation.Nullable String uid) {
    this.uid = uid;
    return this;
  }

  /**
   * Get uid
   * @return uid
   */
  @javax.annotation.Nullable
  public String getUid() {
    return uid;
  }

  public void setUid(@javax.annotation.Nullable String uid) {
    this.uid = uid;
  }


  public ImapServerSearchOptions since(@javax.annotation.Nullable OffsetDateTime since) {
    this.since = since;
    return this;
  }

  /**
   * Get since
   * @return since
   */
  @javax.annotation.Nullable
  public OffsetDateTime getSince() {
    return since;
  }

  public void setSince(@javax.annotation.Nullable OffsetDateTime since) {
    this.since = since;
  }


  public ImapServerSearchOptions before(@javax.annotation.Nullable OffsetDateTime before) {
    this.before = before;
    return this;
  }

  /**
   * Get before
   * @return before
   */
  @javax.annotation.Nullable
  public OffsetDateTime getBefore() {
    return before;
  }

  public void setBefore(@javax.annotation.Nullable OffsetDateTime before) {
    this.before = before;
  }


  public ImapServerSearchOptions sentSince(@javax.annotation.Nullable OffsetDateTime sentSince) {
    this.sentSince = sentSince;
    return this;
  }

  /**
   * Get sentSince
   * @return sentSince
   */
  @javax.annotation.Nullable
  public OffsetDateTime getSentSince() {
    return sentSince;
  }

  public void setSentSince(@javax.annotation.Nullable OffsetDateTime sentSince) {
    this.sentSince = sentSince;
  }


  public ImapServerSearchOptions sentBefore(@javax.annotation.Nullable OffsetDateTime sentBefore) {
    this.sentBefore = sentBefore;
    return this;
  }

  /**
   * Get sentBefore
   * @return sentBefore
   */
  @javax.annotation.Nullable
  public OffsetDateTime getSentBefore() {
    return sentBefore;
  }

  public void setSentBefore(@javax.annotation.Nullable OffsetDateTime sentBefore) {
    this.sentBefore = sentBefore;
  }


  public ImapServerSearchOptions header(@javax.annotation.Nullable Map<String, List<String>> header) {
    this.header = header;
    return this;
  }

  public ImapServerSearchOptions putHeaderItem(String key, List<String> headerItem) {
    if (this.header == null) {
      this.header = new HashMap<>();
    }
    this.header.put(key, headerItem);
    return this;
  }

  /**
   * Get header
   * @return header
   */
  @javax.annotation.Nullable
  public Map<String, List<String>> getHeader() {
    return header;
  }

  public void setHeader(@javax.annotation.Nullable Map<String, List<String>> header) {
    this.header = header;
  }


  public ImapServerSearchOptions body(@javax.annotation.Nullable List<String> body) {
    this.body = body;
    return this;
  }

  public ImapServerSearchOptions addBodyItem(String bodyItem) {
    if (this.body == null) {
      this.body = new ArrayList<>();
    }
    this.body.add(bodyItem);
    return this;
  }

  /**
   * Get body
   * @return body
   */
  @javax.annotation.Nullable
  public List<String> getBody() {
    return body;
  }

  public void setBody(@javax.annotation.Nullable List<String> body) {
    this.body = body;
  }


  public ImapServerSearchOptions text(@javax.annotation.Nullable List<String> text) {
    this.text = text;
    return this;
  }

  public ImapServerSearchOptions addTextItem(String textItem) {
    if (this.text == null) {
      this.text = new ArrayList<>();
    }
    this.text.add(textItem);
    return this;
  }

  /**
   * Get text
   * @return text
   */
  @javax.annotation.Nullable
  public List<String> getText() {
    return text;
  }

  public void setText(@javax.annotation.Nullable List<String> text) {
    this.text = text;
  }


  public ImapServerSearchOptions withFlags(@javax.annotation.Nullable List<String> withFlags) {
    this.withFlags = withFlags;
    return this;
  }

  public ImapServerSearchOptions addWithFlagsItem(String withFlagsItem) {
    if (this.withFlags == null) {
      this.withFlags = new ArrayList<>();
    }
    this.withFlags.add(withFlagsItem);
    return this;
  }

  /**
   * Get withFlags
   * @return withFlags
   */
  @javax.annotation.Nullable
  public List<String> getWithFlags() {
    return withFlags;
  }

  public void setWithFlags(@javax.annotation.Nullable List<String> withFlags) {
    this.withFlags = withFlags;
  }


  public ImapServerSearchOptions withoutFlags(@javax.annotation.Nullable List<String> withoutFlags) {
    this.withoutFlags = withoutFlags;
    return this;
  }

  public ImapServerSearchOptions addWithoutFlagsItem(String withoutFlagsItem) {
    if (this.withoutFlags == null) {
      this.withoutFlags = new ArrayList<>();
    }
    this.withoutFlags.add(withoutFlagsItem);
    return this;
  }

  /**
   * Get withoutFlags
   * @return withoutFlags
   */
  @javax.annotation.Nullable
  public List<String> getWithoutFlags() {
    return withoutFlags;
  }

  public void setWithoutFlags(@javax.annotation.Nullable List<String> withoutFlags) {
    this.withoutFlags = withoutFlags;
  }



  @Override
  public boolean equals(Object o) {
    if (this == o) {
      return true;
    }
    if (o == null || getClass() != o.getClass()) {
      return false;
    }
    ImapServerSearchOptions imapServerSearchOptions = (ImapServerSearchOptions) o;
    return Objects.equals(this.seqNum, imapServerSearchOptions.seqNum) &&
        Objects.equals(this.uid, imapServerSearchOptions.uid) &&
        Objects.equals(this.since, imapServerSearchOptions.since) &&
        Objects.equals(this.before, imapServerSearchOptions.before) &&
        Objects.equals(this.sentSince, imapServerSearchOptions.sentSince) &&
        Objects.equals(this.sentBefore, imapServerSearchOptions.sentBefore) &&
        Objects.equals(this.header, imapServerSearchOptions.header) &&
        Objects.equals(this.body, imapServerSearchOptions.body) &&
        Objects.equals(this.text, imapServerSearchOptions.text) &&
        Objects.equals(this.withFlags, imapServerSearchOptions.withFlags) &&
        Objects.equals(this.withoutFlags, imapServerSearchOptions.withoutFlags);
  }

  private static <T> boolean equalsNullable(JsonNullable<T> a, JsonNullable<T> b) {
    return a == b || (a != null && b != null && a.isPresent() && b.isPresent() && Objects.deepEquals(a.get(), b.get()));
  }

  @Override
  public int hashCode() {
    return Objects.hash(seqNum, uid, since, before, sentSince, sentBefore, header, body, text, withFlags, withoutFlags);
  }

  private static <T> int hashCodeNullable(JsonNullable<T> a) {
    if (a == null) {
      return 1;
    }
    return a.isPresent() ? Arrays.deepHashCode(new Object[]{a.get()}) : 31;
  }

  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append("class ImapServerSearchOptions {\n");
    sb.append("    seqNum: ").append(toIndentedString(seqNum)).append("\n");
    sb.append("    uid: ").append(toIndentedString(uid)).append("\n");
    sb.append("    since: ").append(toIndentedString(since)).append("\n");
    sb.append("    before: ").append(toIndentedString(before)).append("\n");
    sb.append("    sentSince: ").append(toIndentedString(sentSince)).append("\n");
    sb.append("    sentBefore: ").append(toIndentedString(sentBefore)).append("\n");
    sb.append("    header: ").append(toIndentedString(header)).append("\n");
    sb.append("    body: ").append(toIndentedString(body)).append("\n");
    sb.append("    text: ").append(toIndentedString(text)).append("\n");
    sb.append("    withFlags: ").append(toIndentedString(withFlags)).append("\n");
    sb.append("    withoutFlags: ").append(toIndentedString(withoutFlags)).append("\n");
    sb.append("}");
    return sb.toString();
  }

  /**
   * Convert the given object to string with each line indented by 4 spaces
   * (except the first line).
   */
  private String toIndentedString(Object o) {
    if (o == null) {
      return "null";
    }
    return o.toString().replace("\n", "\n    ");
  }


  public static HashSet<String> openapiFields;
  public static HashSet<String> openapiRequiredFields;

  static {
    // a set of all properties/fields (JSON key names)
    openapiFields = new HashSet<String>();
    openapiFields.add("seqNum");
    openapiFields.add("uid");
    openapiFields.add("since");
    openapiFields.add("before");
    openapiFields.add("sentSince");
    openapiFields.add("sentBefore");
    openapiFields.add("header");
    openapiFields.add("body");
    openapiFields.add("text");
    openapiFields.add("withFlags");
    openapiFields.add("withoutFlags");

    // a set of required properties/fields (JSON key names)
    openapiRequiredFields = new HashSet<String>();
  }

  /**
   * Validates the JSON Element and throws an exception if issues found
   *
   * @param jsonElement JSON Element
   * @throws IOException if the JSON Element is invalid with respect to ImapServerSearchOptions
   */
  public static void validateJsonElement(JsonElement jsonElement) throws IOException { if (true) { return; }
      if (jsonElement == null) {
        if (!ImapServerSearchOptions.openapiRequiredFields.isEmpty()) { // has required fields but JSON element is null
          throw new IllegalArgumentException(String.format("The required field(s) %s in ImapServerSearchOptions is not found in the empty JSON string", ImapServerSearchOptions.openapiRequiredFields.toString()));
        }
      }

      Set<Map.Entry<String, JsonElement>> entries = jsonElement.getAsJsonObject().entrySet();
      // check to see if the JSON string contains additional fields
      for (Map.Entry<String, JsonElement> entry : entries) {
        if (!ImapServerSearchOptions.openapiFields.contains(entry.getKey())) {
          throw new IllegalArgumentException(String.format("The field `%s` in the JSON string is not defined in the `ImapServerSearchOptions` properties. JSON: %s", entry.getKey(), jsonElement.toString()));
        }
      }
        JsonObject jsonObj = jsonElement.getAsJsonObject();
      if ((jsonObj.get("seqNum") != null && !jsonObj.get("seqNum").isJsonNull()) && !jsonObj.get("seqNum").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `seqNum` to be a primitive type in the JSON string but got `%s`", jsonObj.get("seqNum").toString()));
      }
      if ((jsonObj.get("uid") != null && !jsonObj.get("uid").isJsonNull()) && !jsonObj.get("uid").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `uid` to be a primitive type in the JSON string but got `%s`", jsonObj.get("uid").toString()));
      }
      // ensure the optional json data is an array if present
      if (jsonObj.get("body") != null && !jsonObj.get("body").isJsonNull() && !jsonObj.get("body").isJsonArray()) {
        throw new IllegalArgumentException(String.format("Expected the field `body` to be an array in the JSON string but got `%s`", jsonObj.get("body").toString()));
      }
      // ensure the optional json data is an array if present
      if (jsonObj.get("text") != null && !jsonObj.get("text").isJsonNull() && !jsonObj.get("text").isJsonArray()) {
        throw new IllegalArgumentException(String.format("Expected the field `text` to be an array in the JSON string but got `%s`", jsonObj.get("text").toString()));
      }
      // ensure the optional json data is an array if present
      if (jsonObj.get("withFlags") != null && !jsonObj.get("withFlags").isJsonNull() && !jsonObj.get("withFlags").isJsonArray()) {
        throw new IllegalArgumentException(String.format("Expected the field `withFlags` to be an array in the JSON string but got `%s`", jsonObj.get("withFlags").toString()));
      }
      // ensure the optional json data is an array if present
      if (jsonObj.get("withoutFlags") != null && !jsonObj.get("withoutFlags").isJsonNull() && !jsonObj.get("withoutFlags").isJsonArray()) {
        throw new IllegalArgumentException(String.format("Expected the field `withoutFlags` to be an array in the JSON string but got `%s`", jsonObj.get("withoutFlags").toString()));
      }
  }

  public static class CustomTypeAdapterFactory implements TypeAdapterFactory {
    @SuppressWarnings("unchecked")
    @Override
    public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> type) {
       if (!ImapServerSearchOptions.class.isAssignableFrom(type.getRawType())) {
         return null; // this class only serializes 'ImapServerSearchOptions' and its subtypes
       }
       final TypeAdapter<JsonElement> elementAdapter = gson.getAdapter(JsonElement.class);
       final TypeAdapter<ImapServerSearchOptions> thisAdapter
                        = gson.getDelegateAdapter(this, TypeToken.get(ImapServerSearchOptions.class));

       return (TypeAdapter<T>) new TypeAdapter<ImapServerSearchOptions>() {
           @Override
           public void write(JsonWriter out, ImapServerSearchOptions value) throws IOException {
             JsonObject obj = thisAdapter.toJsonTree(value).getAsJsonObject();
             elementAdapter.write(out, obj);
           }

           @Override
           public ImapServerSearchOptions read(JsonReader in) throws IOException {
             JsonElement jsonElement = elementAdapter.read(in);
             validateJsonElement(jsonElement);
             return thisAdapter.fromJsonTree(jsonElement);
           }

       }.nullSafe();
    }
  }

  /**
   * Create an instance of ImapServerSearchOptions given an JSON string
   *
   * @param jsonString JSON string
   * @return An instance of ImapServerSearchOptions
   * @throws IOException if the JSON string is invalid with respect to ImapServerSearchOptions
   */
  public static ImapServerSearchOptions fromJson(String jsonString) throws IOException {
    return JSON.getGson().fromJson(jsonString, ImapServerSearchOptions.class);
  }

  /**
   * Convert an instance of ImapServerSearchOptions to an JSON string
   *
   * @return JSON string
   */
  public String toJson() {
    return JSON.getGson().toJson(this);
  }
}

