/*
 * MailSlurp API
 * MailSlurp is an API for sending and receiving emails from dynamically allocated email addresses. It's designed for developers and QA teams to test applications, process inbound emails, send templated notifications, attachments, and more.  ## Resources  - [Homepage](https://www.mailslurp.com) - Get an [API KEY](https://app.mailslurp.com/sign-up/) - Generated [SDK Clients](https://docs.mailslurp.com/) - [Examples](https://github.com/mailslurp/examples) repository
 *
 * The version of the OpenAPI document: 6.5.2
 * Contact: contact@mailslurp.dev
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


package com.mailslurp.models;

import java.util.Objects;
import java.util.Arrays;
import com.google.gson.TypeAdapter;
import com.google.gson.annotations.JsonAdapter;
import com.google.gson.annotations.SerializedName;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import io.swagger.annotations.ApiModel;
import io.swagger.annotations.ApiModelProperty;
import java.io.IOException;
import java.time.OffsetDateTime;
import org.openapitools.jackson.nullable.JsonNullable;

import com.google.gson.Gson;
import com.google.gson.GsonBuilder;
import com.google.gson.JsonArray;
import com.google.gson.JsonDeserializationContext;
import com.google.gson.JsonDeserializer;
import com.google.gson.JsonElement;
import com.google.gson.JsonObject;
import com.google.gson.JsonParseException;
import com.google.gson.TypeAdapterFactory;
import com.google.gson.reflect.TypeToken;

import java.lang.reflect.Type;
import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Map.Entry;
import java.util.Set;

import com.mailslurp.clients.JSON;

/**
 * Expiration defaults for your account
 */
@ApiModel(description = "Expiration defaults for your account")
@javax.annotation.Generated(value = "org.openapitools.codegen.languages.JavaClientCodegen", date = "2023-06-12T12:42:28.001523Z[Etc/UTC]")
public class ExpirationDefaults {
  public static final String SERIALIZED_NAME_DEFAULT_EXPIRATION_MILLIS = "defaultExpirationMillis";
  @SerializedName(SERIALIZED_NAME_DEFAULT_EXPIRATION_MILLIS)
  private Long defaultExpirationMillis;

  public static final String SERIALIZED_NAME_MAX_EXPIRATION_MILLIS = "maxExpirationMillis";
  @SerializedName(SERIALIZED_NAME_MAX_EXPIRATION_MILLIS)
  private Long maxExpirationMillis;

  public static final String SERIALIZED_NAME_DEFAULT_EXPIRES_AT = "defaultExpiresAt";
  @SerializedName(SERIALIZED_NAME_DEFAULT_EXPIRES_AT)
  private OffsetDateTime defaultExpiresAt;

  public static final String SERIALIZED_NAME_CAN_PERMANENT_INBOX = "canPermanentInbox";
  @SerializedName(SERIALIZED_NAME_CAN_PERMANENT_INBOX)
  private Boolean canPermanentInbox;

  public static final String SERIALIZED_NAME_NEXT_INBOX_ALLOWS_PERMANENT = "nextInboxAllowsPermanent";
  @SerializedName(SERIALIZED_NAME_NEXT_INBOX_ALLOWS_PERMANENT)
  private Boolean nextInboxAllowsPermanent;

  public ExpirationDefaults() {
  }

  public ExpirationDefaults defaultExpirationMillis(Long defaultExpirationMillis) {
    
    this.defaultExpirationMillis = defaultExpirationMillis;
    return this;
  }

   /**
   * Get defaultExpirationMillis
   * @return defaultExpirationMillis
  **/
  @javax.annotation.Nullable
  @ApiModelProperty(value = "")

  public Long getDefaultExpirationMillis() {
    return defaultExpirationMillis;
  }


  public void setDefaultExpirationMillis(Long defaultExpirationMillis) {
    this.defaultExpirationMillis = defaultExpirationMillis;
  }


  public ExpirationDefaults maxExpirationMillis(Long maxExpirationMillis) {
    
    this.maxExpirationMillis = maxExpirationMillis;
    return this;
  }

   /**
   * Get maxExpirationMillis
   * @return maxExpirationMillis
  **/
  @javax.annotation.Nullable
  @ApiModelProperty(value = "")

  public Long getMaxExpirationMillis() {
    return maxExpirationMillis;
  }


  public void setMaxExpirationMillis(Long maxExpirationMillis) {
    this.maxExpirationMillis = maxExpirationMillis;
  }


  public ExpirationDefaults defaultExpiresAt(OffsetDateTime defaultExpiresAt) {
    
    this.defaultExpiresAt = defaultExpiresAt;
    return this;
  }

   /**
   * Get defaultExpiresAt
   * @return defaultExpiresAt
  **/
  @javax.annotation.Nullable
  @ApiModelProperty(value = "")

  public OffsetDateTime getDefaultExpiresAt() {
    return defaultExpiresAt;
  }


  public void setDefaultExpiresAt(OffsetDateTime defaultExpiresAt) {
    this.defaultExpiresAt = defaultExpiresAt;
  }


  public ExpirationDefaults canPermanentInbox(Boolean canPermanentInbox) {
    
    this.canPermanentInbox = canPermanentInbox;
    return this;
  }

   /**
   * Get canPermanentInbox
   * @return canPermanentInbox
  **/
  @javax.annotation.Nonnull
  @ApiModelProperty(required = true, value = "")

  public Boolean getCanPermanentInbox() {
    return canPermanentInbox;
  }


  public void setCanPermanentInbox(Boolean canPermanentInbox) {
    this.canPermanentInbox = canPermanentInbox;
  }


  public ExpirationDefaults nextInboxAllowsPermanent(Boolean nextInboxAllowsPermanent) {
    
    this.nextInboxAllowsPermanent = nextInboxAllowsPermanent;
    return this;
  }

   /**
   * Get nextInboxAllowsPermanent
   * @return nextInboxAllowsPermanent
  **/
  @javax.annotation.Nonnull
  @ApiModelProperty(required = true, value = "")

  public Boolean getNextInboxAllowsPermanent() {
    return nextInboxAllowsPermanent;
  }


  public void setNextInboxAllowsPermanent(Boolean nextInboxAllowsPermanent) {
    this.nextInboxAllowsPermanent = nextInboxAllowsPermanent;
  }



  @Override
  public boolean equals(Object o) {
    if (this == o) {
      return true;
    }
    if (o == null || getClass() != o.getClass()) {
      return false;
    }
    ExpirationDefaults expirationDefaults = (ExpirationDefaults) o;
    return Objects.equals(this.defaultExpirationMillis, expirationDefaults.defaultExpirationMillis) &&
        Objects.equals(this.maxExpirationMillis, expirationDefaults.maxExpirationMillis) &&
        Objects.equals(this.defaultExpiresAt, expirationDefaults.defaultExpiresAt) &&
        Objects.equals(this.canPermanentInbox, expirationDefaults.canPermanentInbox) &&
        Objects.equals(this.nextInboxAllowsPermanent, expirationDefaults.nextInboxAllowsPermanent);
  }

  private static <T> boolean equalsNullable(JsonNullable<T> a, JsonNullable<T> b) {
    return a == b || (a != null && b != null && a.isPresent() && b.isPresent() && Objects.deepEquals(a.get(), b.get()));
  }

  @Override
  public int hashCode() {
    return Objects.hash(defaultExpirationMillis, maxExpirationMillis, defaultExpiresAt, canPermanentInbox, nextInboxAllowsPermanent);
  }

  private static <T> int hashCodeNullable(JsonNullable<T> a) {
    if (a == null) {
      return 1;
    }
    return a.isPresent() ? Arrays.deepHashCode(new Object[]{a.get()}) : 31;
  }

  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append("class ExpirationDefaults {\n");
    sb.append("    defaultExpirationMillis: ").append(toIndentedString(defaultExpirationMillis)).append("\n");
    sb.append("    maxExpirationMillis: ").append(toIndentedString(maxExpirationMillis)).append("\n");
    sb.append("    defaultExpiresAt: ").append(toIndentedString(defaultExpiresAt)).append("\n");
    sb.append("    canPermanentInbox: ").append(toIndentedString(canPermanentInbox)).append("\n");
    sb.append("    nextInboxAllowsPermanent: ").append(toIndentedString(nextInboxAllowsPermanent)).append("\n");
    sb.append("}");
    return sb.toString();
  }

  /**
   * Convert the given object to string with each line indented by 4 spaces
   * (except the first line).
   */
  private String toIndentedString(Object o) {
    if (o == null) {
      return "null";
    }
    return o.toString().replace("\n", "\n    ");
  }


  public static HashSet<String> openapiFields;
  public static HashSet<String> openapiRequiredFields;

  static {
    // a set of all properties/fields (JSON key names)
    openapiFields = new HashSet<String>();
    openapiFields.add("defaultExpirationMillis");
    openapiFields.add("maxExpirationMillis");
    openapiFields.add("defaultExpiresAt");
    openapiFields.add("canPermanentInbox");
    openapiFields.add("nextInboxAllowsPermanent");

    // a set of required properties/fields (JSON key names)
    openapiRequiredFields = new HashSet<String>();
    openapiRequiredFields.add("canPermanentInbox");
    openapiRequiredFields.add("nextInboxAllowsPermanent");
  }

 /**
  * Validates the JSON Object and throws an exception if issues found
  *
  * @param jsonObj JSON Object
  * @throws IOException if the JSON Object is invalid with respect to ExpirationDefaults
  */
  public static void validateJsonObject(JsonObject jsonObj) throws IOException {
      if (jsonObj == null) {
        if (!ExpirationDefaults.openapiRequiredFields.isEmpty()) { // has required fields but JSON object is null
          throw new IllegalArgumentException(String.format("The required field(s) %s in ExpirationDefaults is not found in the empty JSON string", ExpirationDefaults.openapiRequiredFields.toString()));
        }
      }

      Set<Entry<String, JsonElement>> entries = jsonObj.entrySet();
      // check to see if the JSON string contains additional fields
      for (Entry<String, JsonElement> entry : entries) {
        if (!ExpirationDefaults.openapiFields.contains(entry.getKey())) {
          throw new IllegalArgumentException(String.format("The field `%s` in the JSON string is not defined in the `ExpirationDefaults` properties. JSON: %s", entry.getKey(), jsonObj.toString()));
        }
      }

      // check to make sure all required properties/fields are present in the JSON string
      for (String requiredField : ExpirationDefaults.openapiRequiredFields) {
        if (jsonObj.get(requiredField) == null) {
          throw new IllegalArgumentException(String.format("The required field `%s` is not found in the JSON string: %s", requiredField, jsonObj.toString()));
        }
      }
  }

  public static class CustomTypeAdapterFactory implements TypeAdapterFactory {
    @SuppressWarnings("unchecked")
    @Override
    public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> type) {
       if (!ExpirationDefaults.class.isAssignableFrom(type.getRawType())) {
         return null; // this class only serializes 'ExpirationDefaults' and its subtypes
       }
       final TypeAdapter<JsonElement> elementAdapter = gson.getAdapter(JsonElement.class);
       final TypeAdapter<ExpirationDefaults> thisAdapter
                        = gson.getDelegateAdapter(this, TypeToken.get(ExpirationDefaults.class));

       return (TypeAdapter<T>) new TypeAdapter<ExpirationDefaults>() {
           @Override
           public void write(JsonWriter out, ExpirationDefaults value) throws IOException {
             JsonObject obj = thisAdapter.toJsonTree(value).getAsJsonObject();
             elementAdapter.write(out, obj);
           }

           @Override
           public ExpirationDefaults read(JsonReader in) throws IOException {
             JsonObject jsonObj = elementAdapter.read(in).getAsJsonObject();
             validateJsonObject(jsonObj);
             return thisAdapter.fromJsonTree(jsonObj);
           }

       }.nullSafe();
    }
  }

 /**
  * Create an instance of ExpirationDefaults given an JSON string
  *
  * @param jsonString JSON string
  * @return An instance of ExpirationDefaults
  * @throws IOException if the JSON string is invalid with respect to ExpirationDefaults
  */
  public static ExpirationDefaults fromJson(String jsonString) throws IOException {
    return JSON.getGson().fromJson(jsonString, ExpirationDefaults.class);
  }

 /**
  * Convert an instance of ExpirationDefaults to an JSON string
  *
  * @return JSON string
  */
  public String toJson() {
    return JSON.getGson().toJson(this);
  }
}

