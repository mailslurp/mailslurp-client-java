/*
 * MailSlurp API
 * MailSlurp is an API for sending and receiving emails and SMS from dynamically allocated email addresses and phone numbers. It's designed for developers and QA teams to test applications, process inbound emails, send templated notifications, attachments, and more.  ## Resources  - [Homepage](https://www.mailslurp.com) - Get an [API KEY](https://app.mailslurp.com/sign-up/) - Generated [SDK Clients](https://docs.mailslurp.com/) - [Examples](https://github.com/mailslurp/examples) repository
 *
 * The version of the OpenAPI document: 6.5.2
 * Contact: contact@mailslurp.dev
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


package com.mailslurp.models;

import java.util.Objects;
import com.google.gson.TypeAdapter;
import com.google.gson.annotations.JsonAdapter;
import com.google.gson.annotations.SerializedName;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import com.mailslurp.models.SendEmailBodyPart;
import java.io.IOException;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.UUID;
import org.openapitools.jackson.nullable.JsonNullable;

import com.google.gson.Gson;
import com.google.gson.GsonBuilder;
import com.google.gson.JsonArray;
import com.google.gson.JsonDeserializationContext;
import com.google.gson.JsonDeserializer;
import com.google.gson.JsonElement;
import com.google.gson.JsonObject;
import com.google.gson.JsonParseException;
import com.google.gson.TypeAdapterFactory;
import com.google.gson.reflect.TypeToken;
import com.google.gson.TypeAdapter;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;

import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;

import com.mailslurp.clients.JSON;

/**
 * Options for the email to be sent
 */
@javax.annotation.Generated(value = "org.openapitools.codegen.languages.JavaClientCodegen", date = "2025-07-29T22:03:04.172026956Z[Etc/UTC]", comments = "Generator version: 7.13.0")
public class SendEmailOptions {
  public static final String SERIALIZED_NAME_TO_CONTACTS = "toContacts";
  @SerializedName(SERIALIZED_NAME_TO_CONTACTS)
  @javax.annotation.Nullable
  private List<UUID> toContacts;

  public static final String SERIALIZED_NAME_TO_GROUP = "toGroup";
  @SerializedName(SERIALIZED_NAME_TO_GROUP)
  @javax.annotation.Nullable
  private UUID toGroup;

  public static final String SERIALIZED_NAME_TO = "to";
  @SerializedName(SERIALIZED_NAME_TO)
  @javax.annotation.Nullable
  private List<String> to;

  public static final String SERIALIZED_NAME_FROM = "from";
  @SerializedName(SERIALIZED_NAME_FROM)
  @javax.annotation.Nullable
  private String from;

  public static final String SERIALIZED_NAME_FROM_NAME = "fromName";
  @SerializedName(SERIALIZED_NAME_FROM_NAME)
  @javax.annotation.Nullable
  private String fromName;

  public static final String SERIALIZED_NAME_CC = "cc";
  @SerializedName(SERIALIZED_NAME_CC)
  @javax.annotation.Nullable
  private List<String> cc;

  public static final String SERIALIZED_NAME_BCC = "bcc";
  @SerializedName(SERIALIZED_NAME_BCC)
  @javax.annotation.Nullable
  private List<String> bcc;

  public static final String SERIALIZED_NAME_SUBJECT = "subject";
  @SerializedName(SERIALIZED_NAME_SUBJECT)
  @javax.annotation.Nullable
  private String subject;

  public static final String SERIALIZED_NAME_REPLY_TO = "replyTo";
  @SerializedName(SERIALIZED_NAME_REPLY_TO)
  @javax.annotation.Nullable
  private String replyTo;

  public static final String SERIALIZED_NAME_CUSTOM_HEADERS = "customHeaders";
  @SerializedName(SERIALIZED_NAME_CUSTOM_HEADERS)
  @javax.annotation.Nullable
  private Map<String, String> customHeaders;

  public static final String SERIALIZED_NAME_BODY = "body";
  @SerializedName(SERIALIZED_NAME_BODY)
  @javax.annotation.Nullable
  private String body;

  public static final String SERIALIZED_NAME_HTML = "html";
  @SerializedName(SERIALIZED_NAME_HTML)
  @javax.annotation.Nullable
  private Boolean html;

  public static final String SERIALIZED_NAME_IS_H_T_M_L = "isHTML";
  @SerializedName(SERIALIZED_NAME_IS_H_T_M_L)
  @javax.annotation.Nullable
  private Boolean isHTML;

  public static final String SERIALIZED_NAME_CHARSET = "charset";
  @SerializedName(SERIALIZED_NAME_CHARSET)
  @javax.annotation.Nullable
  private String charset;

  public static final String SERIALIZED_NAME_ATTACHMENTS = "attachments";
  @SerializedName(SERIALIZED_NAME_ATTACHMENTS)
  @javax.annotation.Nullable
  private List<String> attachments;

  public static final String SERIALIZED_NAME_TEMPLATE_VARIABLES = "templateVariables";
  @SerializedName(SERIALIZED_NAME_TEMPLATE_VARIABLES)
  @javax.annotation.Nullable
  private Map<String, Object> templateVariables;

  public static final String SERIALIZED_NAME_TEMPLATE = "template";
  @SerializedName(SERIALIZED_NAME_TEMPLATE)
  @javax.annotation.Nullable
  private UUID template;

  /**
   * How an email should be sent based on its recipients
   */
  @JsonAdapter(SendStrategyEnum.Adapter.class)
  public enum SendStrategyEnum {
    SINGLE_MESSAGE("SINGLE_MESSAGE");

    private String value;

    SendStrategyEnum(String value) {
      this.value = value;
    }

    public String getValue() {
      return value;
    }

    @Override
    public String toString() {
      return String.valueOf(value);
    }

    public static SendStrategyEnum fromValue(String value) {
      for (SendStrategyEnum b : SendStrategyEnum.values()) {
        if (b.value.equals(value)) {
          return b;
        }
      }
      return null;
    }

    public static class Adapter extends TypeAdapter<SendStrategyEnum> {
      @Override
      public void write(final JsonWriter jsonWriter, final SendStrategyEnum enumeration) throws IOException {
        jsonWriter.value(enumeration.getValue());
      }

      @Override
      public SendStrategyEnum read(final JsonReader jsonReader) throws IOException {
        String value =  jsonReader.nextString();
        return SendStrategyEnum.fromValue(value);
      }
    }

    public static void validateJsonElement(JsonElement jsonElement) throws IOException { if (true) { return; }
      String value = jsonElement.getAsString();
      SendStrategyEnum.fromValue(value);
    }
  }

  public static final String SERIALIZED_NAME_SEND_STRATEGY = "sendStrategy";
  @SerializedName(SERIALIZED_NAME_SEND_STRATEGY)
  @javax.annotation.Nullable
  private SendStrategyEnum sendStrategy;

  public static final String SERIALIZED_NAME_USE_INBOX_NAME = "useInboxName";
  @SerializedName(SERIALIZED_NAME_USE_INBOX_NAME)
  @javax.annotation.Nullable
  private Boolean useInboxName;

  public static final String SERIALIZED_NAME_ADD_TRACKING_PIXEL = "addTrackingPixel";
  @SerializedName(SERIALIZED_NAME_ADD_TRACKING_PIXEL)
  @javax.annotation.Nullable
  private Boolean addTrackingPixel;

  public static final String SERIALIZED_NAME_FILTER_BOUNCED_RECIPIENTS = "filterBouncedRecipients";
  @SerializedName(SERIALIZED_NAME_FILTER_BOUNCED_RECIPIENTS)
  @javax.annotation.Nullable
  private Boolean filterBouncedRecipients;

  /**
   * Validate recipient email addresses before sending
   */
  @JsonAdapter(ValidateEmailAddressesEnum.Adapter.class)
  public enum ValidateEmailAddressesEnum {
    VALIDATE_FILTER_REMOVE_INVALID("VALIDATE_FILTER_REMOVE_INVALID"),
    
    VALIDATE_ERROR_IF_INVALID("VALIDATE_ERROR_IF_INVALID"),
    
    NO_VALIDATION("NO_VALIDATION");

    private String value;

    ValidateEmailAddressesEnum(String value) {
      this.value = value;
    }

    public String getValue() {
      return value;
    }

    @Override
    public String toString() {
      return String.valueOf(value);
    }

    public static ValidateEmailAddressesEnum fromValue(String value) {
      for (ValidateEmailAddressesEnum b : ValidateEmailAddressesEnum.values()) {
        if (b.value.equals(value)) {
          return b;
        }
      }
      return null;
    }

    public static class Adapter extends TypeAdapter<ValidateEmailAddressesEnum> {
      @Override
      public void write(final JsonWriter jsonWriter, final ValidateEmailAddressesEnum enumeration) throws IOException {
        jsonWriter.value(enumeration.getValue());
      }

      @Override
      public ValidateEmailAddressesEnum read(final JsonReader jsonReader) throws IOException {
        String value =  jsonReader.nextString();
        return ValidateEmailAddressesEnum.fromValue(value);
      }
    }

    public static void validateJsonElement(JsonElement jsonElement) throws IOException { if (true) { return; }
      String value = jsonElement.getAsString();
      ValidateEmailAddressesEnum.fromValue(value);
    }
  }

  public static final String SERIALIZED_NAME_VALIDATE_EMAIL_ADDRESSES = "validateEmailAddresses";
  @SerializedName(SERIALIZED_NAME_VALIDATE_EMAIL_ADDRESSES)
  @javax.annotation.Nullable
  private ValidateEmailAddressesEnum validateEmailAddresses;

  public static final String SERIALIZED_NAME_IGNORE_EMPTY_RECIPIENTS = "ignoreEmptyRecipients";
  @SerializedName(SERIALIZED_NAME_IGNORE_EMPTY_RECIPIENTS)
  @javax.annotation.Nullable
  private Boolean ignoreEmptyRecipients;

  public static final String SERIALIZED_NAME_IS_X_AMP_HTML = "isXAmpHtml";
  @SerializedName(SERIALIZED_NAME_IS_X_AMP_HTML)
  @javax.annotation.Nullable
  private Boolean isXAmpHtml;

  public static final String SERIALIZED_NAME_BODY_PARTS = "bodyParts";
  @SerializedName(SERIALIZED_NAME_BODY_PARTS)
  @javax.annotation.Nullable
  private List<SendEmailBodyPart> bodyParts;

  public SendEmailOptions() {
  }

  public SendEmailOptions toContacts(@javax.annotation.Nullable List<UUID> toContacts) {
    this.toContacts = toContacts;
    return this;
  }

  public SendEmailOptions addToContactsItem(UUID toContactsItem) {
    if (this.toContacts == null) {
      this.toContacts = new ArrayList<>();
    }
    this.toContacts.add(toContactsItem);
    return this;
  }

  /**
   * Optional list of contact IDs to send email to. Manage your contacts via the API or dashboard. When contacts are used the email is sent to each contact separately so they will not see other recipients.
   * @return toContacts
   */
  @javax.annotation.Nullable
  public List<UUID> getToContacts() {
    return toContacts;
  }

  public void setToContacts(@javax.annotation.Nullable List<UUID> toContacts) {
    this.toContacts = toContacts;
  }


  public SendEmailOptions toGroup(@javax.annotation.Nullable UUID toGroup) {
    this.toGroup = toGroup;
    return this;
  }

  /**
   * Optional contact group ID to send email to. You can create contacts and contact groups in the API or dashboard and use them for email campaigns. When contact groups are used the email is sent to each contact separately so they will not see other recipients
   * @return toGroup
   */
  @javax.annotation.Nullable
  public UUID getToGroup() {
    return toGroup;
  }

  public void setToGroup(@javax.annotation.Nullable UUID toGroup) {
    this.toGroup = toGroup;
  }


  public SendEmailOptions to(@javax.annotation.Nullable List<String> to) {
    this.to = to;
    return this;
  }

  public SendEmailOptions addToItem(String toItem) {
    if (this.to == null) {
      this.to = new ArrayList<>();
    }
    this.to.add(toItem);
    return this;
  }

  /**
   * List of destination email addresses. Each email address must be RFC 5322 format. Even single recipients must be in array form. Maximum recipients per email depends on your plan. If you need to send many emails try using contacts or contact groups or use a non standard sendStrategy to ensure that spam filters are not triggered (many recipients in one email can affect your spam rating). Be cautious when sending emails that your recipients exist. High bounce rates (meaning a high percentage of emails cannot be delivered because an address does not exist) can result in account freezing.
   * @return to
   */
  @javax.annotation.Nullable
  public List<String> getTo() {
    return to;
  }

  public void setTo(@javax.annotation.Nullable List<String> to) {
    this.to = to;
  }


  public SendEmailOptions from(@javax.annotation.Nullable String from) {
    this.from = from;
    return this;
  }

  /**
   * Optional from address. Email address is RFC 5322 format and may include a display name and email in angle brackets (&#x60;my@address.com&#x60; or &#x60;My inbox &lt;my@address.com&gt;&#x60;). If no sender is set the source inbox address will be used for this field. If you set &#x60;useInboxName&#x60; to &#x60;true&#x60; the from field will include the inbox name as a display name: &#x60;inbox_name &lt;inbox@address.com&gt;&#x60;. For this to work use the name field when creating an inbox. Beware of potential spam penalties when setting the from field to an address not used by the inbox. Your emails may get blocked by services if you impersonate another address. To use a custom email addresses use a custom domain. You can create domains with the DomainController. The domain must be verified in the dashboard before it can be used.
   * @return from
   */
  @javax.annotation.Nullable
  public String getFrom() {
    return from;
  }

  public void setFrom(@javax.annotation.Nullable String from) {
    this.from = from;
  }


  public SendEmailOptions fromName(@javax.annotation.Nullable String fromName) {
    this.fromName = fromName;
    return this;
  }

  /**
   * Optional from name if not passed with address. If you set &#x60;useInboxName&#x60; to &#x60;true&#x60; the from field will include the inbox name as a display name
   * @return fromName
   */
  @javax.annotation.Nullable
  public String getFromName() {
    return fromName;
  }

  public void setFromName(@javax.annotation.Nullable String fromName) {
    this.fromName = fromName;
  }


  public SendEmailOptions cc(@javax.annotation.Nullable List<String> cc) {
    this.cc = cc;
    return this;
  }

  public SendEmailOptions addCcItem(String ccItem) {
    if (this.cc == null) {
      this.cc = new ArrayList<>();
    }
    this.cc.add(ccItem);
    return this;
  }

  /**
   * Optional list of cc destination email addresses
   * @return cc
   */
  @javax.annotation.Nullable
  public List<String> getCc() {
    return cc;
  }

  public void setCc(@javax.annotation.Nullable List<String> cc) {
    this.cc = cc;
  }


  public SendEmailOptions bcc(@javax.annotation.Nullable List<String> bcc) {
    this.bcc = bcc;
    return this;
  }

  public SendEmailOptions addBccItem(String bccItem) {
    if (this.bcc == null) {
      this.bcc = new ArrayList<>();
    }
    this.bcc.add(bccItem);
    return this;
  }

  /**
   * Optional list of bcc destination email addresses
   * @return bcc
   */
  @javax.annotation.Nullable
  public List<String> getBcc() {
    return bcc;
  }

  public void setBcc(@javax.annotation.Nullable List<String> bcc) {
    this.bcc = bcc;
  }


  public SendEmailOptions subject(@javax.annotation.Nullable String subject) {
    this.subject = subject;
    return this;
  }

  /**
   * Optional email subject line
   * @return subject
   */
  @javax.annotation.Nullable
  public String getSubject() {
    return subject;
  }

  public void setSubject(@javax.annotation.Nullable String subject) {
    this.subject = subject;
  }


  public SendEmailOptions replyTo(@javax.annotation.Nullable String replyTo) {
    this.replyTo = replyTo;
    return this;
  }

  /**
   * Optional replyTo header
   * @return replyTo
   */
  @javax.annotation.Nullable
  public String getReplyTo() {
    return replyTo;
  }

  public void setReplyTo(@javax.annotation.Nullable String replyTo) {
    this.replyTo = replyTo;
  }


  public SendEmailOptions customHeaders(@javax.annotation.Nullable Map<String, String> customHeaders) {
    this.customHeaders = customHeaders;
    return this;
  }

  public SendEmailOptions putCustomHeadersItem(String key, String customHeadersItem) {
    if (this.customHeaders == null) {
      this.customHeaders = new HashMap<>();
    }
    this.customHeaders.put(key, customHeadersItem);
    return this;
  }

  /**
   * Optional custom headers
   * @return customHeaders
   */
  @javax.annotation.Nullable
  public Map<String, String> getCustomHeaders() {
    return customHeaders;
  }

  public void setCustomHeaders(@javax.annotation.Nullable Map<String, String> customHeaders) {
    this.customHeaders = customHeaders;
  }


  public SendEmailOptions body(@javax.annotation.Nullable String body) {
    this.body = body;
    return this;
  }

  /**
   * Optional contents of email. If body contains HTML then set &#x60;isHTML&#x60; to true to ensure that email clients render it correctly. You can use moustache template syntax in the email body in conjunction with &#x60;toGroup&#x60; contact variables or &#x60;templateVariables&#x60; data. If you need more templating control consider creating a template and using the &#x60;template&#x60; property instead of the body.
   * @return body
   */
  @javax.annotation.Nullable
  public String getBody() {
    return body;
  }

  public void setBody(@javax.annotation.Nullable String body) {
    this.body = body;
  }


  public SendEmailOptions html(@javax.annotation.Nullable Boolean html) {
    this.html = html;
    return this;
  }

  /**
   * Optional HTML flag to indicate that contents is HTML. Set&#39;s a &#x60;content-type: text/html&#x60; for email. (Deprecated: use &#x60;isHTML&#x60; instead.)
   * @return html
   */
  @javax.annotation.Nullable
  public Boolean getHtml() {
    return html;
  }

  public void setHtml(@javax.annotation.Nullable Boolean html) {
    this.html = html;
  }


  public SendEmailOptions isHTML(@javax.annotation.Nullable Boolean isHTML) {
    this.isHTML = isHTML;
    return this;
  }

  /**
   * Optional HTML flag. If true the &#x60;content-type&#x60; of the email will be &#x60;text/html&#x60;. Set to true when sending HTML to ensure proper rending on email clients
   * @return isHTML
   */
  @javax.annotation.Nullable
  public Boolean getIsHTML() {
    return isHTML;
  }

  public void setIsHTML(@javax.annotation.Nullable Boolean isHTML) {
    this.isHTML = isHTML;
  }


  public SendEmailOptions charset(@javax.annotation.Nullable String charset) {
    this.charset = charset;
    return this;
  }

  /**
   * Optional charset
   * @return charset
   */
  @javax.annotation.Nullable
  public String getCharset() {
    return charset;
  }

  public void setCharset(@javax.annotation.Nullable String charset) {
    this.charset = charset;
  }


  public SendEmailOptions attachments(@javax.annotation.Nullable List<String> attachments) {
    this.attachments = attachments;
    return this;
  }

  public SendEmailOptions addAttachmentsItem(String attachmentsItem) {
    if (this.attachments == null) {
      this.attachments = new ArrayList<>();
    }
    this.attachments.add(attachmentsItem);
    return this;
  }

  /**
   * Optional list of attachment IDs to send with this email. You must first upload each attachment separately via method call or dashboard in order to obtain attachment IDs. This way you can reuse attachments with different emails once uploaded. There are several ways to upload that support &#x60;multi-part form&#x60;, &#x60;base64 file encoding&#x60;, and octet stream binary uploads. See the &#x60;UploadController&#x60; for available methods. 
   * @return attachments
   */
  @javax.annotation.Nullable
  public List<String> getAttachments() {
    return attachments;
  }

  public void setAttachments(@javax.annotation.Nullable List<String> attachments) {
    this.attachments = attachments;
  }


  public SendEmailOptions templateVariables(@javax.annotation.Nullable Map<String, Object> templateVariables) {
    this.templateVariables = templateVariables;
    return this;
  }

  public SendEmailOptions putTemplateVariablesItem(String key, Object templateVariablesItem) {
    if (this.templateVariables == null) {
      this.templateVariables = new HashMap<>();
    }
    this.templateVariables.put(key, templateVariablesItem);
    return this;
  }

  /**
   * Optional map of template variables. Will replace moustache syntax variables in subject and body or template with the associated values if found.
   * @return templateVariables
   */
  @javax.annotation.Nullable
  public Map<String, Object> getTemplateVariables() {
    return templateVariables;
  }

  public void setTemplateVariables(@javax.annotation.Nullable Map<String, Object> templateVariables) {
    this.templateVariables = templateVariables;
  }


  public SendEmailOptions template(@javax.annotation.Nullable UUID template) {
    this.template = template;
    return this;
  }

  /**
   * Optional template ID to use for body. Will override body if provided. When using a template make sure you pass the corresponding map of &#x60;templateVariables&#x60;. You can find which variables are needed by fetching the template itself or viewing it in the dashboard.
   * @return template
   */
  @javax.annotation.Nullable
  public UUID getTemplate() {
    return template;
  }

  public void setTemplate(@javax.annotation.Nullable UUID template) {
    this.template = template;
  }


  public SendEmailOptions sendStrategy(@javax.annotation.Nullable SendStrategyEnum sendStrategy) {
    this.sendStrategy = sendStrategy;
    return this;
  }

  /**
   * How an email should be sent based on its recipients
   * @return sendStrategy
   */
  @javax.annotation.Nullable
  public SendStrategyEnum getSendStrategy() {
    return sendStrategy;
  }

  public void setSendStrategy(@javax.annotation.Nullable SendStrategyEnum sendStrategy) {
    this.sendStrategy = sendStrategy;
  }


  public SendEmailOptions useInboxName(@javax.annotation.Nullable Boolean useInboxName) {
    this.useInboxName = useInboxName;
    return this;
  }

  /**
   * Use name of inbox as sender email address name. Will construct RFC 5322 email address with &#x60;Inbox name &lt;inbox@address.com&gt;&#x60; if the inbox has a name.
   * @return useInboxName
   */
  @javax.annotation.Nullable
  public Boolean getUseInboxName() {
    return useInboxName;
  }

  public void setUseInboxName(@javax.annotation.Nullable Boolean useInboxName) {
    this.useInboxName = useInboxName;
  }


  public SendEmailOptions addTrackingPixel(@javax.annotation.Nullable Boolean addTrackingPixel) {
    this.addTrackingPixel = addTrackingPixel;
    return this;
  }

  /**
   * Add tracking pixel to email
   * @return addTrackingPixel
   */
  @javax.annotation.Nullable
  public Boolean getAddTrackingPixel() {
    return addTrackingPixel;
  }

  public void setAddTrackingPixel(@javax.annotation.Nullable Boolean addTrackingPixel) {
    this.addTrackingPixel = addTrackingPixel;
  }


  public SendEmailOptions filterBouncedRecipients(@javax.annotation.Nullable Boolean filterBouncedRecipients) {
    this.filterBouncedRecipients = filterBouncedRecipients;
    return this;
  }

  /**
   * Filter recipients to remove any bounced recipients from to, bcc, and cc before sending
   * @return filterBouncedRecipients
   */
  @javax.annotation.Nullable
  public Boolean getFilterBouncedRecipients() {
    return filterBouncedRecipients;
  }

  public void setFilterBouncedRecipients(@javax.annotation.Nullable Boolean filterBouncedRecipients) {
    this.filterBouncedRecipients = filterBouncedRecipients;
  }


  public SendEmailOptions validateEmailAddresses(@javax.annotation.Nullable ValidateEmailAddressesEnum validateEmailAddresses) {
    this.validateEmailAddresses = validateEmailAddresses;
    return this;
  }

  /**
   * Validate recipient email addresses before sending
   * @return validateEmailAddresses
   */
  @javax.annotation.Nullable
  public ValidateEmailAddressesEnum getValidateEmailAddresses() {
    return validateEmailAddresses;
  }

  public void setValidateEmailAddresses(@javax.annotation.Nullable ValidateEmailAddressesEnum validateEmailAddresses) {
    this.validateEmailAddresses = validateEmailAddresses;
  }


  public SendEmailOptions ignoreEmptyRecipients(@javax.annotation.Nullable Boolean ignoreEmptyRecipients) {
    this.ignoreEmptyRecipients = ignoreEmptyRecipients;
    return this;
  }

  /**
   * Ignore empty recipients after validation removes all recipients as invalid and fail silently
   * @return ignoreEmptyRecipients
   */
  @javax.annotation.Nullable
  public Boolean getIgnoreEmptyRecipients() {
    return ignoreEmptyRecipients;
  }

  public void setIgnoreEmptyRecipients(@javax.annotation.Nullable Boolean ignoreEmptyRecipients) {
    this.ignoreEmptyRecipients = ignoreEmptyRecipients;
  }


  public SendEmailOptions isXAmpHtml(@javax.annotation.Nullable Boolean isXAmpHtml) {
    this.isXAmpHtml = isXAmpHtml;
    return this;
  }

  /**
   * Is content AMP4EMAIL compatible. If set will send as x-amp-html part.
   * @return isXAmpHtml
   */
  @javax.annotation.Nullable
  public Boolean getIsXAmpHtml() {
    return isXAmpHtml;
  }

  public void setIsXAmpHtml(@javax.annotation.Nullable Boolean isXAmpHtml) {
    this.isXAmpHtml = isXAmpHtml;
  }


  public SendEmailOptions bodyParts(@javax.annotation.Nullable List<SendEmailBodyPart> bodyParts) {
    this.bodyParts = bodyParts;
    return this;
  }

  public SendEmailOptions addBodyPartsItem(SendEmailBodyPart bodyPartsItem) {
    if (this.bodyParts == null) {
      this.bodyParts = new ArrayList<>();
    }
    this.bodyParts.add(bodyPartsItem);
    return this;
  }

  /**
   * Email body content parts for multipart mime message. Will override body.
   * @return bodyParts
   */
  @javax.annotation.Nullable
  public List<SendEmailBodyPart> getBodyParts() {
    return bodyParts;
  }

  public void setBodyParts(@javax.annotation.Nullable List<SendEmailBodyPart> bodyParts) {
    this.bodyParts = bodyParts;
  }



  @Override
  public boolean equals(Object o) {
    if (this == o) {
      return true;
    }
    if (o == null || getClass() != o.getClass()) {
      return false;
    }
    SendEmailOptions sendEmailOptions = (SendEmailOptions) o;
    return Objects.equals(this.toContacts, sendEmailOptions.toContacts) &&
        Objects.equals(this.toGroup, sendEmailOptions.toGroup) &&
        Objects.equals(this.to, sendEmailOptions.to) &&
        Objects.equals(this.from, sendEmailOptions.from) &&
        Objects.equals(this.fromName, sendEmailOptions.fromName) &&
        Objects.equals(this.cc, sendEmailOptions.cc) &&
        Objects.equals(this.bcc, sendEmailOptions.bcc) &&
        Objects.equals(this.subject, sendEmailOptions.subject) &&
        Objects.equals(this.replyTo, sendEmailOptions.replyTo) &&
        Objects.equals(this.customHeaders, sendEmailOptions.customHeaders) &&
        Objects.equals(this.body, sendEmailOptions.body) &&
        Objects.equals(this.html, sendEmailOptions.html) &&
        Objects.equals(this.isHTML, sendEmailOptions.isHTML) &&
        Objects.equals(this.charset, sendEmailOptions.charset) &&
        Objects.equals(this.attachments, sendEmailOptions.attachments) &&
        Objects.equals(this.templateVariables, sendEmailOptions.templateVariables) &&
        Objects.equals(this.template, sendEmailOptions.template) &&
        Objects.equals(this.sendStrategy, sendEmailOptions.sendStrategy) &&
        Objects.equals(this.useInboxName, sendEmailOptions.useInboxName) &&
        Objects.equals(this.addTrackingPixel, sendEmailOptions.addTrackingPixel) &&
        Objects.equals(this.filterBouncedRecipients, sendEmailOptions.filterBouncedRecipients) &&
        Objects.equals(this.validateEmailAddresses, sendEmailOptions.validateEmailAddresses) &&
        Objects.equals(this.ignoreEmptyRecipients, sendEmailOptions.ignoreEmptyRecipients) &&
        Objects.equals(this.isXAmpHtml, sendEmailOptions.isXAmpHtml) &&
        Objects.equals(this.bodyParts, sendEmailOptions.bodyParts);
  }

  private static <T> boolean equalsNullable(JsonNullable<T> a, JsonNullable<T> b) {
    return a == b || (a != null && b != null && a.isPresent() && b.isPresent() && Objects.deepEquals(a.get(), b.get()));
  }

  @Override
  public int hashCode() {
    return Objects.hash(toContacts, toGroup, to, from, fromName, cc, bcc, subject, replyTo, customHeaders, body, html, isHTML, charset, attachments, templateVariables, template, sendStrategy, useInboxName, addTrackingPixel, filterBouncedRecipients, validateEmailAddresses, ignoreEmptyRecipients, isXAmpHtml, bodyParts);
  }

  private static <T> int hashCodeNullable(JsonNullable<T> a) {
    if (a == null) {
      return 1;
    }
    return a.isPresent() ? Arrays.deepHashCode(new Object[]{a.get()}) : 31;
  }

  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append("class SendEmailOptions {\n");
    sb.append("    toContacts: ").append(toIndentedString(toContacts)).append("\n");
    sb.append("    toGroup: ").append(toIndentedString(toGroup)).append("\n");
    sb.append("    to: ").append(toIndentedString(to)).append("\n");
    sb.append("    from: ").append(toIndentedString(from)).append("\n");
    sb.append("    fromName: ").append(toIndentedString(fromName)).append("\n");
    sb.append("    cc: ").append(toIndentedString(cc)).append("\n");
    sb.append("    bcc: ").append(toIndentedString(bcc)).append("\n");
    sb.append("    subject: ").append(toIndentedString(subject)).append("\n");
    sb.append("    replyTo: ").append(toIndentedString(replyTo)).append("\n");
    sb.append("    customHeaders: ").append(toIndentedString(customHeaders)).append("\n");
    sb.append("    body: ").append(toIndentedString(body)).append("\n");
    sb.append("    html: ").append(toIndentedString(html)).append("\n");
    sb.append("    isHTML: ").append(toIndentedString(isHTML)).append("\n");
    sb.append("    charset: ").append(toIndentedString(charset)).append("\n");
    sb.append("    attachments: ").append(toIndentedString(attachments)).append("\n");
    sb.append("    templateVariables: ").append(toIndentedString(templateVariables)).append("\n");
    sb.append("    template: ").append(toIndentedString(template)).append("\n");
    sb.append("    sendStrategy: ").append(toIndentedString(sendStrategy)).append("\n");
    sb.append("    useInboxName: ").append(toIndentedString(useInboxName)).append("\n");
    sb.append("    addTrackingPixel: ").append(toIndentedString(addTrackingPixel)).append("\n");
    sb.append("    filterBouncedRecipients: ").append(toIndentedString(filterBouncedRecipients)).append("\n");
    sb.append("    validateEmailAddresses: ").append(toIndentedString(validateEmailAddresses)).append("\n");
    sb.append("    ignoreEmptyRecipients: ").append(toIndentedString(ignoreEmptyRecipients)).append("\n");
    sb.append("    isXAmpHtml: ").append(toIndentedString(isXAmpHtml)).append("\n");
    sb.append("    bodyParts: ").append(toIndentedString(bodyParts)).append("\n");
    sb.append("}");
    return sb.toString();
  }

  /**
   * Convert the given object to string with each line indented by 4 spaces
   * (except the first line).
   */
  private String toIndentedString(Object o) {
    if (o == null) {
      return "null";
    }
    return o.toString().replace("\n", "\n    ");
  }


  public static HashSet<String> openapiFields;
  public static HashSet<String> openapiRequiredFields;

  static {
    // a set of all properties/fields (JSON key names)
    openapiFields = new HashSet<String>();
    openapiFields.add("toContacts");
    openapiFields.add("toGroup");
    openapiFields.add("to");
    openapiFields.add("from");
    openapiFields.add("fromName");
    openapiFields.add("cc");
    openapiFields.add("bcc");
    openapiFields.add("subject");
    openapiFields.add("replyTo");
    openapiFields.add("customHeaders");
    openapiFields.add("body");
    openapiFields.add("html");
    openapiFields.add("isHTML");
    openapiFields.add("charset");
    openapiFields.add("attachments");
    openapiFields.add("templateVariables");
    openapiFields.add("template");
    openapiFields.add("sendStrategy");
    openapiFields.add("useInboxName");
    openapiFields.add("addTrackingPixel");
    openapiFields.add("filterBouncedRecipients");
    openapiFields.add("validateEmailAddresses");
    openapiFields.add("ignoreEmptyRecipients");
    openapiFields.add("isXAmpHtml");
    openapiFields.add("bodyParts");

    // a set of required properties/fields (JSON key names)
    openapiRequiredFields = new HashSet<String>();
  }

  /**
   * Validates the JSON Element and throws an exception if issues found
   *
   * @param jsonElement JSON Element
   * @throws IOException if the JSON Element is invalid with respect to SendEmailOptions
   */
  public static void validateJsonElement(JsonElement jsonElement) throws IOException { if (true) { return; }
      if (jsonElement == null) {
        if (!SendEmailOptions.openapiRequiredFields.isEmpty()) { // has required fields but JSON element is null
          throw new IllegalArgumentException(String.format("The required field(s) %s in SendEmailOptions is not found in the empty JSON string", SendEmailOptions.openapiRequiredFields.toString()));
        }
      }

      Set<Map.Entry<String, JsonElement>> entries = jsonElement.getAsJsonObject().entrySet();
      // check to see if the JSON string contains additional fields
      for (Map.Entry<String, JsonElement> entry : entries) {
        if (!SendEmailOptions.openapiFields.contains(entry.getKey())) {
          throw new IllegalArgumentException(String.format("The field `%s` in the JSON string is not defined in the `SendEmailOptions` properties. JSON: %s", entry.getKey(), jsonElement.toString()));
        }
      }
        JsonObject jsonObj = jsonElement.getAsJsonObject();
      // ensure the optional json data is an array if present
      if (jsonObj.get("toContacts") != null && !jsonObj.get("toContacts").isJsonNull() && !jsonObj.get("toContacts").isJsonArray()) {
        throw new IllegalArgumentException(String.format("Expected the field `toContacts` to be an array in the JSON string but got `%s`", jsonObj.get("toContacts").toString()));
      }
      if ((jsonObj.get("toGroup") != null && !jsonObj.get("toGroup").isJsonNull()) && !jsonObj.get("toGroup").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `toGroup` to be a primitive type in the JSON string but got `%s`", jsonObj.get("toGroup").toString()));
      }
      // ensure the optional json data is an array if present
      if (jsonObj.get("to") != null && !jsonObj.get("to").isJsonNull() && !jsonObj.get("to").isJsonArray()) {
        throw new IllegalArgumentException(String.format("Expected the field `to` to be an array in the JSON string but got `%s`", jsonObj.get("to").toString()));
      }
      if ((jsonObj.get("from") != null && !jsonObj.get("from").isJsonNull()) && !jsonObj.get("from").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `from` to be a primitive type in the JSON string but got `%s`", jsonObj.get("from").toString()));
      }
      if ((jsonObj.get("fromName") != null && !jsonObj.get("fromName").isJsonNull()) && !jsonObj.get("fromName").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `fromName` to be a primitive type in the JSON string but got `%s`", jsonObj.get("fromName").toString()));
      }
      // ensure the optional json data is an array if present
      if (jsonObj.get("cc") != null && !jsonObj.get("cc").isJsonNull() && !jsonObj.get("cc").isJsonArray()) {
        throw new IllegalArgumentException(String.format("Expected the field `cc` to be an array in the JSON string but got `%s`", jsonObj.get("cc").toString()));
      }
      // ensure the optional json data is an array if present
      if (jsonObj.get("bcc") != null && !jsonObj.get("bcc").isJsonNull() && !jsonObj.get("bcc").isJsonArray()) {
        throw new IllegalArgumentException(String.format("Expected the field `bcc` to be an array in the JSON string but got `%s`", jsonObj.get("bcc").toString()));
      }
      if ((jsonObj.get("subject") != null && !jsonObj.get("subject").isJsonNull()) && !jsonObj.get("subject").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `subject` to be a primitive type in the JSON string but got `%s`", jsonObj.get("subject").toString()));
      }
      if ((jsonObj.get("replyTo") != null && !jsonObj.get("replyTo").isJsonNull()) && !jsonObj.get("replyTo").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `replyTo` to be a primitive type in the JSON string but got `%s`", jsonObj.get("replyTo").toString()));
      }
      if ((jsonObj.get("body") != null && !jsonObj.get("body").isJsonNull()) && !jsonObj.get("body").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `body` to be a primitive type in the JSON string but got `%s`", jsonObj.get("body").toString()));
      }
      if ((jsonObj.get("charset") != null && !jsonObj.get("charset").isJsonNull()) && !jsonObj.get("charset").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `charset` to be a primitive type in the JSON string but got `%s`", jsonObj.get("charset").toString()));
      }
      // ensure the optional json data is an array if present
      if (jsonObj.get("attachments") != null && !jsonObj.get("attachments").isJsonNull() && !jsonObj.get("attachments").isJsonArray()) {
        throw new IllegalArgumentException(String.format("Expected the field `attachments` to be an array in the JSON string but got `%s`", jsonObj.get("attachments").toString()));
      }
      if ((jsonObj.get("template") != null && !jsonObj.get("template").isJsonNull()) && !jsonObj.get("template").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `template` to be a primitive type in the JSON string but got `%s`", jsonObj.get("template").toString()));
      }
      if ((jsonObj.get("sendStrategy") != null && !jsonObj.get("sendStrategy").isJsonNull()) && !jsonObj.get("sendStrategy").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `sendStrategy` to be a primitive type in the JSON string but got `%s`", jsonObj.get("sendStrategy").toString()));
      }
      // validate the optional field `sendStrategy`
      if (jsonObj.get("sendStrategy") != null && !jsonObj.get("sendStrategy").isJsonNull()) {
        SendStrategyEnum.validateJsonElement(jsonObj.get("sendStrategy"));
      }
      if ((jsonObj.get("validateEmailAddresses") != null && !jsonObj.get("validateEmailAddresses").isJsonNull()) && !jsonObj.get("validateEmailAddresses").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `validateEmailAddresses` to be a primitive type in the JSON string but got `%s`", jsonObj.get("validateEmailAddresses").toString()));
      }
      // validate the optional field `validateEmailAddresses`
      if (jsonObj.get("validateEmailAddresses") != null && !jsonObj.get("validateEmailAddresses").isJsonNull()) {
        ValidateEmailAddressesEnum.validateJsonElement(jsonObj.get("validateEmailAddresses"));
      }
      if (jsonObj.get("bodyParts") != null && !jsonObj.get("bodyParts").isJsonNull()) {
        JsonArray jsonArraybodyParts = jsonObj.getAsJsonArray("bodyParts");
        if (jsonArraybodyParts != null) {
          // ensure the json data is an array
          if (!jsonObj.get("bodyParts").isJsonArray()) {
            throw new IllegalArgumentException(String.format("Expected the field `bodyParts` to be an array in the JSON string but got `%s`", jsonObj.get("bodyParts").toString()));
          }

          // validate the optional field `bodyParts` (array)
          for (int i = 0; i < jsonArraybodyParts.size(); i++) {
            SendEmailBodyPart.validateJsonElement(jsonArraybodyParts.get(i));
          };
        }
      }
  }

  public static class CustomTypeAdapterFactory implements TypeAdapterFactory {
    @SuppressWarnings("unchecked")
    @Override
    public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> type) {
       if (!SendEmailOptions.class.isAssignableFrom(type.getRawType())) {
         return null; // this class only serializes 'SendEmailOptions' and its subtypes
       }
       final TypeAdapter<JsonElement> elementAdapter = gson.getAdapter(JsonElement.class);
       final TypeAdapter<SendEmailOptions> thisAdapter
                        = gson.getDelegateAdapter(this, TypeToken.get(SendEmailOptions.class));

       return (TypeAdapter<T>) new TypeAdapter<SendEmailOptions>() {
           @Override
           public void write(JsonWriter out, SendEmailOptions value) throws IOException {
             JsonObject obj = thisAdapter.toJsonTree(value).getAsJsonObject();
             elementAdapter.write(out, obj);
           }

           @Override
           public SendEmailOptions read(JsonReader in) throws IOException {
             JsonElement jsonElement = elementAdapter.read(in);
             validateJsonElement(jsonElement);
             return thisAdapter.fromJsonTree(jsonElement);
           }

       }.nullSafe();
    }
  }

  /**
   * Create an instance of SendEmailOptions given an JSON string
   *
   * @param jsonString JSON string
   * @return An instance of SendEmailOptions
   * @throws IOException if the JSON string is invalid with respect to SendEmailOptions
   */
  public static SendEmailOptions fromJson(String jsonString) throws IOException {
    return JSON.getGson().fromJson(jsonString, SendEmailOptions.class);
  }

  /**
   * Convert an instance of SendEmailOptions to an JSON string
   *
   * @return JSON string
   */
  public String toJson() {
    return JSON.getGson().toJson(this);
  }
}

