/*
 * MailSlurp API
 * MailSlurp is an API for sending and receiving emails and SMS from dynamically allocated email addresses and phone numbers. It's designed for developers and QA teams to test applications, process inbound emails, send templated notifications, attachments, and more.  ## Resources  - [Homepage](https://www.mailslurp.com) - Get an [API KEY](https://app.mailslurp.com/sign-up/) - Generated [SDK Clients](https://docs.mailslurp.com/) - [Examples](https://github.com/mailslurp/examples) repository
 *
 * The version of the OpenAPI document: 6.5.2
 * Contact: contact@mailslurp.dev
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


package com.mailslurp.apis;

import com.mailslurp.clients.ApiCallback;
import com.mailslurp.clients.ApiClient;
import com.mailslurp.clients.ApiException;
import com.mailslurp.clients.ApiResponse;
import com.mailslurp.clients.Configuration;
import com.mailslurp.clients.Pair;
import com.mailslurp.clients.ProgressRequestBody;
import com.mailslurp.clients.ProgressResponseBody;

import com.google.gson.reflect.TypeToken;

import java.io.IOException;


import com.mailslurp.models.Email;
import com.mailslurp.models.EmailPreview;
import com.mailslurp.models.MatchOptions;
import java.time.OffsetDateTime;
import com.mailslurp.models.SmsDto;
import com.mailslurp.models.SmsPreview;
import java.util.UUID;
import com.mailslurp.models.WaitForConditions;
import com.mailslurp.models.WaitForSingleSmsOptions;
import com.mailslurp.models.WaitForSmsConditions;

import java.lang.reflect.Type;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

public class WaitForControllerApi {
    private ApiClient localVarApiClient;
    private int localHostIndex;
    private String localCustomBaseUrl;

    public WaitForControllerApi() {
        this(Configuration.getDefaultApiClient());
    }

    public WaitForControllerApi(ApiClient apiClient) {
        this.localVarApiClient = apiClient;
    }

    public ApiClient getApiClient() {
        return localVarApiClient;
    }

    public void setApiClient(ApiClient apiClient) {
        this.localVarApiClient = apiClient;
    }

    public int getHostIndex() {
        return localHostIndex;
    }

    public void setHostIndex(int hostIndex) {
        this.localHostIndex = hostIndex;
    }

    public String getCustomBaseUrl() {
        return localCustomBaseUrl;
    }

    public void setCustomBaseUrl(String customBaseUrl) {
        this.localCustomBaseUrl = customBaseUrl;
    }

    private okhttp3.Call waitForCall(@javax.annotation.Nonnull WaitForConditions waitForConditions, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = waitForConditions;

        // create path and map variables
        String localVarPath = "/waitFor";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {
            "*/*"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
            "application/json"
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "API_KEY" };
        return localVarApiClient.buildCall(basePath, localVarPath, "POST", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call waitForValidateBeforeCall(@javax.annotation.Nonnull WaitForConditions waitForConditions, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'waitForConditions' is set
        if (waitForConditions == null) {
            throw new ApiException("Missing the required parameter 'waitForConditions' when calling waitFor(Async)");
        }

        return waitForCall(waitForConditions, _callback);

    }


    private ApiResponse<List<EmailPreview>> waitForWithHttpInfo(@javax.annotation.Nonnull WaitForConditions waitForConditions) throws ApiException {
        okhttp3.Call localVarCall = waitForValidateBeforeCall(waitForConditions, null);
        Type localVarReturnType = new TypeToken<List<EmailPreview>>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    private okhttp3.Call waitForAsync(@javax.annotation.Nonnull WaitForConditions waitForConditions, final ApiCallback<List<EmailPreview>> _callback) throws ApiException {

        okhttp3.Call localVarCall = waitForValidateBeforeCall(waitForConditions, _callback);
        Type localVarReturnType = new TypeToken<List<EmailPreview>>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }

    public class APIwaitForRequest {
        @javax.annotation.Nonnull
        private final WaitForConditions waitForConditions;

        private APIwaitForRequest(@javax.annotation.Nonnull WaitForConditions waitForConditions) {
            this.waitForConditions = waitForConditions;
        }

        /**
         * Build call for waitFor
         * @param _callback ApiCallback API callback
         * @return Call to execute
         * @throws ApiException If fail to serialize the request body object
         * @http.response.details
         <table border="1">
       <caption>Response Details</caption>
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
         </table>
         */
        public okhttp3.Call buildCall(final ApiCallback _callback) throws ApiException {
            return waitForCall(waitForConditions, _callback);
        }

        /**
         * Execute waitFor request
         * @return List&lt;EmailPreview&gt;
         * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
         * @http.response.details
         <table border="1">
       <caption>Response Details</caption>
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
         </table>
         */
        public List<EmailPreview> execute() throws ApiException {
            ApiResponse<List<EmailPreview>> localVarResp = waitForWithHttpInfo(waitForConditions);
            return localVarResp.getData();
        }

        /**
         * Execute waitFor request with HTTP info returned
         * @return ApiResponse&lt;List&lt;EmailPreview&gt;&gt;
         * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
         * @http.response.details
         <table border="1">
       <caption>Response Details</caption>
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
         </table>
         */
        public ApiResponse<List<EmailPreview>> executeWithHttpInfo() throws ApiException {
            return waitForWithHttpInfo(waitForConditions);
        }

        /**
         * Execute waitFor request (asynchronously)
         * @param _callback The callback to be executed when the API call finishes
         * @return The request call
         * @throws ApiException If fail to process the API call, e.g. serializing the request body object
         * @http.response.details
         <table border="1">
       <caption>Response Details</caption>
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
         </table>
         */
        public okhttp3.Call executeAsync(final ApiCallback<List<EmailPreview>> _callback) throws ApiException {
            return waitForAsync(waitForConditions, _callback);
        }
    }

    /**
     * Wait for an email to match the provided filter conditions such as subject contains keyword.
     * Generic waitFor method that will wait until an inbox meets given conditions or return immediately if already met
     * @param waitForConditions  (required)
     * @return APIwaitForRequest
     * @http.response.details
     <table border="1">
       <caption>Response Details</caption>
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
     </table>
     */
    public APIwaitForRequest waitFor(@javax.annotation.Nonnull WaitForConditions waitForConditions) {
        return new APIwaitForRequest(waitForConditions);
    }
    private okhttp3.Call waitForEmailCountCall(@javax.annotation.Nonnull UUID inboxId, @javax.annotation.Nonnull Integer count, @javax.annotation.Nullable Long timeout, @javax.annotation.Nullable Boolean unreadOnly, @javax.annotation.Nullable OffsetDateTime before, @javax.annotation.Nullable OffsetDateTime since, @javax.annotation.Nullable String sort, @javax.annotation.Nullable Long delay, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/waitForEmailCount";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (inboxId != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("inboxId", inboxId));
        }

        if (count != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("count", count));
        }

        if (timeout != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("timeout", timeout));
        }

        if (unreadOnly != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("unreadOnly", unreadOnly));
        }

        if (before != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("before", before));
        }

        if (since != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("since", since));
        }

        if (sort != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("sort", sort));
        }

        if (delay != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("delay", delay));
        }

        final String[] localVarAccepts = {
            "*/*"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "API_KEY" };
        return localVarApiClient.buildCall(basePath, localVarPath, "GET", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call waitForEmailCountValidateBeforeCall(@javax.annotation.Nonnull UUID inboxId, @javax.annotation.Nonnull Integer count, @javax.annotation.Nullable Long timeout, @javax.annotation.Nullable Boolean unreadOnly, @javax.annotation.Nullable OffsetDateTime before, @javax.annotation.Nullable OffsetDateTime since, @javax.annotation.Nullable String sort, @javax.annotation.Nullable Long delay, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'inboxId' is set
        if (inboxId == null) {
            throw new ApiException("Missing the required parameter 'inboxId' when calling waitForEmailCount(Async)");
        }

        // verify the required parameter 'count' is set
        if (count == null) {
            throw new ApiException("Missing the required parameter 'count' when calling waitForEmailCount(Async)");
        }

        return waitForEmailCountCall(inboxId, count, timeout, unreadOnly, before, since, sort, delay, _callback);

    }


    private ApiResponse<List<EmailPreview>> waitForEmailCountWithHttpInfo(@javax.annotation.Nonnull UUID inboxId, @javax.annotation.Nonnull Integer count, @javax.annotation.Nullable Long timeout, @javax.annotation.Nullable Boolean unreadOnly, @javax.annotation.Nullable OffsetDateTime before, @javax.annotation.Nullable OffsetDateTime since, @javax.annotation.Nullable String sort, @javax.annotation.Nullable Long delay) throws ApiException {
        okhttp3.Call localVarCall = waitForEmailCountValidateBeforeCall(inboxId, count, timeout, unreadOnly, before, since, sort, delay, null);
        Type localVarReturnType = new TypeToken<List<EmailPreview>>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    private okhttp3.Call waitForEmailCountAsync(@javax.annotation.Nonnull UUID inboxId, @javax.annotation.Nonnull Integer count, @javax.annotation.Nullable Long timeout, @javax.annotation.Nullable Boolean unreadOnly, @javax.annotation.Nullable OffsetDateTime before, @javax.annotation.Nullable OffsetDateTime since, @javax.annotation.Nullable String sort, @javax.annotation.Nullable Long delay, final ApiCallback<List<EmailPreview>> _callback) throws ApiException {

        okhttp3.Call localVarCall = waitForEmailCountValidateBeforeCall(inboxId, count, timeout, unreadOnly, before, since, sort, delay, _callback);
        Type localVarReturnType = new TypeToken<List<EmailPreview>>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }

    public class APIwaitForEmailCountRequest {
        @javax.annotation.Nonnull
        private final UUID inboxId;
        @javax.annotation.Nonnull
        private final Integer count;
        @javax.annotation.Nullable
        private Long timeout;
        @javax.annotation.Nullable
        private Boolean unreadOnly;
        @javax.annotation.Nullable
        private OffsetDateTime before;
        @javax.annotation.Nullable
        private OffsetDateTime since;
        @javax.annotation.Nullable
        private String sort;
        @javax.annotation.Nullable
        private Long delay;

        private APIwaitForEmailCountRequest(@javax.annotation.Nonnull UUID inboxId, @javax.annotation.Nonnull Integer count) {
            this.inboxId = inboxId;
            this.count = count;
        }

        /**
         * Set timeout
         * @param timeout Max milliseconds to wait (optional)
         * @return APIwaitForEmailCountRequest
         */
        public APIwaitForEmailCountRequest timeout(@javax.annotation.Nullable Long timeout) {
            this.timeout = timeout;
            return this;
        }

        /**
         * Set unreadOnly
         * @param unreadOnly Optional filter for unread only (optional, default to false)
         * @return APIwaitForEmailCountRequest
         */
        public APIwaitForEmailCountRequest unreadOnly(@javax.annotation.Nullable Boolean unreadOnly) {
            this.unreadOnly = unreadOnly;
            return this;
        }

        /**
         * Set before
         * @param before Filter for emails that were received before the given timestamp (optional)
         * @return APIwaitForEmailCountRequest
         */
        public APIwaitForEmailCountRequest before(@javax.annotation.Nullable OffsetDateTime before) {
            this.before = before;
            return this;
        }

        /**
         * Set since
         * @param since Filter for emails that were received after the given timestamp (optional)
         * @return APIwaitForEmailCountRequest
         */
        public APIwaitForEmailCountRequest since(@javax.annotation.Nullable OffsetDateTime since) {
            this.since = since;
            return this;
        }

        /**
         * Set sort
         * @param sort Sort direction (optional)
         * @return APIwaitForEmailCountRequest
         */
        public APIwaitForEmailCountRequest sort(@javax.annotation.Nullable String sort) {
            this.sort = sort;
            return this;
        }

        /**
         * Set delay
         * @param delay Max milliseconds delay between calls (optional)
         * @return APIwaitForEmailCountRequest
         */
        public APIwaitForEmailCountRequest delay(@javax.annotation.Nullable Long delay) {
            this.delay = delay;
            return this;
        }

        /**
         * Build call for waitForEmailCount
         * @param _callback ApiCallback API callback
         * @return Call to execute
         * @throws ApiException If fail to serialize the request body object
         * @http.response.details
         <table border="1">
       <caption>Response Details</caption>
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
         </table>
         */
        public okhttp3.Call buildCall(final ApiCallback _callback) throws ApiException {
            return waitForEmailCountCall(inboxId, count, timeout, unreadOnly, before, since, sort, delay, _callback);
        }

        /**
         * Execute waitForEmailCount request
         * @return List&lt;EmailPreview&gt;
         * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
         * @http.response.details
         <table border="1">
       <caption>Response Details</caption>
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
         </table>
         */
        public List<EmailPreview> execute() throws ApiException {
            ApiResponse<List<EmailPreview>> localVarResp = waitForEmailCountWithHttpInfo(inboxId, count, timeout, unreadOnly, before, since, sort, delay);
            return localVarResp.getData();
        }

        /**
         * Execute waitForEmailCount request with HTTP info returned
         * @return ApiResponse&lt;List&lt;EmailPreview&gt;&gt;
         * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
         * @http.response.details
         <table border="1">
       <caption>Response Details</caption>
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
         </table>
         */
        public ApiResponse<List<EmailPreview>> executeWithHttpInfo() throws ApiException {
            return waitForEmailCountWithHttpInfo(inboxId, count, timeout, unreadOnly, before, since, sort, delay);
        }

        /**
         * Execute waitForEmailCount request (asynchronously)
         * @param _callback The callback to be executed when the API call finishes
         * @return The request call
         * @throws ApiException If fail to process the API call, e.g. serializing the request body object
         * @http.response.details
         <table border="1">
       <caption>Response Details</caption>
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
         </table>
         */
        public okhttp3.Call executeAsync(final ApiCallback<List<EmailPreview>> _callback) throws ApiException {
            return waitForEmailCountAsync(inboxId, count, timeout, unreadOnly, before, since, sort, delay, _callback);
        }
    }

    /**
     * Wait for and return count number of emails. Hold connection until inbox count matches expected or timeout occurs
     * If inbox contains count or more emails at time of request then return count worth of emails. If not wait until the count is reached and return those or return an error if timeout is exceeded.
     * @param inboxId Id of the inbox we are fetching emails from (required)
     * @param count Number of emails to wait for. Must be greater that 1 (required)
     * @return APIwaitForEmailCountRequest
     * @http.response.details
     <table border="1">
       <caption>Response Details</caption>
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
     </table>
     */
    public APIwaitForEmailCountRequest waitForEmailCount(@javax.annotation.Nonnull UUID inboxId, @javax.annotation.Nonnull Integer count) {
        return new APIwaitForEmailCountRequest(inboxId, count);
    }
    private okhttp3.Call waitForLatestEmailCall(@javax.annotation.Nullable UUID inboxId, @javax.annotation.Nullable Long timeout, @javax.annotation.Nullable Boolean unreadOnly, @javax.annotation.Nullable OffsetDateTime before, @javax.annotation.Nullable OffsetDateTime since, @javax.annotation.Nullable String sort, @javax.annotation.Nullable Long delay, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/waitForLatestEmail";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (inboxId != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("inboxId", inboxId));
        }

        if (timeout != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("timeout", timeout));
        }

        if (unreadOnly != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("unreadOnly", unreadOnly));
        }

        if (before != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("before", before));
        }

        if (since != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("since", since));
        }

        if (sort != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("sort", sort));
        }

        if (delay != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("delay", delay));
        }

        final String[] localVarAccepts = {
            "*/*"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "API_KEY" };
        return localVarApiClient.buildCall(basePath, localVarPath, "GET", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call waitForLatestEmailValidateBeforeCall(@javax.annotation.Nullable UUID inboxId, @javax.annotation.Nullable Long timeout, @javax.annotation.Nullable Boolean unreadOnly, @javax.annotation.Nullable OffsetDateTime before, @javax.annotation.Nullable OffsetDateTime since, @javax.annotation.Nullable String sort, @javax.annotation.Nullable Long delay, final ApiCallback _callback) throws ApiException {
        return waitForLatestEmailCall(inboxId, timeout, unreadOnly, before, since, sort, delay, _callback);

    }


    private ApiResponse<Email> waitForLatestEmailWithHttpInfo(@javax.annotation.Nullable UUID inboxId, @javax.annotation.Nullable Long timeout, @javax.annotation.Nullable Boolean unreadOnly, @javax.annotation.Nullable OffsetDateTime before, @javax.annotation.Nullable OffsetDateTime since, @javax.annotation.Nullable String sort, @javax.annotation.Nullable Long delay) throws ApiException {
        okhttp3.Call localVarCall = waitForLatestEmailValidateBeforeCall(inboxId, timeout, unreadOnly, before, since, sort, delay, null);
        Type localVarReturnType = new TypeToken<Email>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    private okhttp3.Call waitForLatestEmailAsync(@javax.annotation.Nullable UUID inboxId, @javax.annotation.Nullable Long timeout, @javax.annotation.Nullable Boolean unreadOnly, @javax.annotation.Nullable OffsetDateTime before, @javax.annotation.Nullable OffsetDateTime since, @javax.annotation.Nullable String sort, @javax.annotation.Nullable Long delay, final ApiCallback<Email> _callback) throws ApiException {

        okhttp3.Call localVarCall = waitForLatestEmailValidateBeforeCall(inboxId, timeout, unreadOnly, before, since, sort, delay, _callback);
        Type localVarReturnType = new TypeToken<Email>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }

    public class APIwaitForLatestEmailRequest {
        @javax.annotation.Nullable
        private UUID inboxId;
        @javax.annotation.Nullable
        private Long timeout;
        @javax.annotation.Nullable
        private Boolean unreadOnly;
        @javax.annotation.Nullable
        private OffsetDateTime before;
        @javax.annotation.Nullable
        private OffsetDateTime since;
        @javax.annotation.Nullable
        private String sort;
        @javax.annotation.Nullable
        private Long delay;

        private APIwaitForLatestEmailRequest() {
        }

        /**
         * Set inboxId
         * @param inboxId Id of the inbox we are fetching emails from (optional)
         * @return APIwaitForLatestEmailRequest
         */
        public APIwaitForLatestEmailRequest inboxId(@javax.annotation.Nullable UUID inboxId) {
            this.inboxId = inboxId;
            return this;
        }

        /**
         * Set timeout
         * @param timeout Max milliseconds to wait (optional)
         * @return APIwaitForLatestEmailRequest
         */
        public APIwaitForLatestEmailRequest timeout(@javax.annotation.Nullable Long timeout) {
            this.timeout = timeout;
            return this;
        }

        /**
         * Set unreadOnly
         * @param unreadOnly Optional filter for unread only. (optional, default to false)
         * @return APIwaitForLatestEmailRequest
         */
        public APIwaitForLatestEmailRequest unreadOnly(@javax.annotation.Nullable Boolean unreadOnly) {
            this.unreadOnly = unreadOnly;
            return this;
        }

        /**
         * Set before
         * @param before Filter for emails that were before after the given timestamp (optional)
         * @return APIwaitForLatestEmailRequest
         */
        public APIwaitForLatestEmailRequest before(@javax.annotation.Nullable OffsetDateTime before) {
            this.before = before;
            return this;
        }

        /**
         * Set since
         * @param since Filter for emails that were received after the given timestamp (optional)
         * @return APIwaitForLatestEmailRequest
         */
        public APIwaitForLatestEmailRequest since(@javax.annotation.Nullable OffsetDateTime since) {
            this.since = since;
            return this;
        }

        /**
         * Set sort
         * @param sort Sort direction (optional)
         * @return APIwaitForLatestEmailRequest
         */
        public APIwaitForLatestEmailRequest sort(@javax.annotation.Nullable String sort) {
            this.sort = sort;
            return this;
        }

        /**
         * Set delay
         * @param delay Max milliseconds delay between calls (optional)
         * @return APIwaitForLatestEmailRequest
         */
        public APIwaitForLatestEmailRequest delay(@javax.annotation.Nullable Long delay) {
            this.delay = delay;
            return this;
        }

        /**
         * Build call for waitForLatestEmail
         * @param _callback ApiCallback API callback
         * @return Call to execute
         * @throws ApiException If fail to serialize the request body object
         * @http.response.details
         <table border="1">
       <caption>Response Details</caption>
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
         </table>
         */
        public okhttp3.Call buildCall(final ApiCallback _callback) throws ApiException {
            return waitForLatestEmailCall(inboxId, timeout, unreadOnly, before, since, sort, delay, _callback);
        }

        /**
         * Execute waitForLatestEmail request
         * @return Email
         * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
         * @http.response.details
         <table border="1">
       <caption>Response Details</caption>
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
         </table>
         */
        public Email execute() throws ApiException {
            ApiResponse<Email> localVarResp = waitForLatestEmailWithHttpInfo(inboxId, timeout, unreadOnly, before, since, sort, delay);
            return localVarResp.getData();
        }

        /**
         * Execute waitForLatestEmail request with HTTP info returned
         * @return ApiResponse&lt;Email&gt;
         * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
         * @http.response.details
         <table border="1">
       <caption>Response Details</caption>
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
         </table>
         */
        public ApiResponse<Email> executeWithHttpInfo() throws ApiException {
            return waitForLatestEmailWithHttpInfo(inboxId, timeout, unreadOnly, before, since, sort, delay);
        }

        /**
         * Execute waitForLatestEmail request (asynchronously)
         * @param _callback The callback to be executed when the API call finishes
         * @return The request call
         * @throws ApiException If fail to process the API call, e.g. serializing the request body object
         * @http.response.details
         <table border="1">
       <caption>Response Details</caption>
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
         </table>
         */
        public okhttp3.Call executeAsync(final ApiCallback<Email> _callback) throws ApiException {
            return waitForLatestEmailAsync(inboxId, timeout, unreadOnly, before, since, sort, delay, _callback);
        }
    }

    /**
     * Fetch inbox&#39;s latest email or if empty wait for an email to arrive
     * Will return either the last received email or wait for an email to arrive and return that. If you need to wait for an email for a non-empty inbox set &#x60;unreadOnly&#x3D;true&#x60; or see the other receive methods such as &#x60;waitForNthEmail&#x60; or &#x60;waitForEmailCount&#x60;.
     * @return APIwaitForLatestEmailRequest
     * @http.response.details
     <table border="1">
       <caption>Response Details</caption>
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
     </table>
     */
    public APIwaitForLatestEmailRequest waitForLatestEmail() {
        return new APIwaitForLatestEmailRequest();
    }
    private okhttp3.Call waitForLatestSmsCall(@javax.annotation.Nonnull WaitForSingleSmsOptions waitForSingleSmsOptions, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = waitForSingleSmsOptions;

        // create path and map variables
        String localVarPath = "/waitForLatestSms";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {
            "*/*"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
            "application/json"
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "API_KEY" };
        return localVarApiClient.buildCall(basePath, localVarPath, "POST", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call waitForLatestSmsValidateBeforeCall(@javax.annotation.Nonnull WaitForSingleSmsOptions waitForSingleSmsOptions, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'waitForSingleSmsOptions' is set
        if (waitForSingleSmsOptions == null) {
            throw new ApiException("Missing the required parameter 'waitForSingleSmsOptions' when calling waitForLatestSms(Async)");
        }

        return waitForLatestSmsCall(waitForSingleSmsOptions, _callback);

    }


    private ApiResponse<SmsDto> waitForLatestSmsWithHttpInfo(@javax.annotation.Nonnull WaitForSingleSmsOptions waitForSingleSmsOptions) throws ApiException {
        okhttp3.Call localVarCall = waitForLatestSmsValidateBeforeCall(waitForSingleSmsOptions, null);
        Type localVarReturnType = new TypeToken<SmsDto>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    private okhttp3.Call waitForLatestSmsAsync(@javax.annotation.Nonnull WaitForSingleSmsOptions waitForSingleSmsOptions, final ApiCallback<SmsDto> _callback) throws ApiException {

        okhttp3.Call localVarCall = waitForLatestSmsValidateBeforeCall(waitForSingleSmsOptions, _callback);
        Type localVarReturnType = new TypeToken<SmsDto>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }

    public class APIwaitForLatestSmsRequest {
        @javax.annotation.Nonnull
        private final WaitForSingleSmsOptions waitForSingleSmsOptions;

        private APIwaitForLatestSmsRequest(@javax.annotation.Nonnull WaitForSingleSmsOptions waitForSingleSmsOptions) {
            this.waitForSingleSmsOptions = waitForSingleSmsOptions;
        }

        /**
         * Build call for waitForLatestSms
         * @param _callback ApiCallback API callback
         * @return Call to execute
         * @throws ApiException If fail to serialize the request body object
         * @http.response.details
         <table border="1">
       <caption>Response Details</caption>
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
         </table>
         */
        public okhttp3.Call buildCall(final ApiCallback _callback) throws ApiException {
            return waitForLatestSmsCall(waitForSingleSmsOptions, _callback);
        }

        /**
         * Execute waitForLatestSms request
         * @return SmsDto
         * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
         * @http.response.details
         <table border="1">
       <caption>Response Details</caption>
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
         </table>
         */
        public SmsDto execute() throws ApiException {
            ApiResponse<SmsDto> localVarResp = waitForLatestSmsWithHttpInfo(waitForSingleSmsOptions);
            return localVarResp.getData();
        }

        /**
         * Execute waitForLatestSms request with HTTP info returned
         * @return ApiResponse&lt;SmsDto&gt;
         * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
         * @http.response.details
         <table border="1">
       <caption>Response Details</caption>
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
         </table>
         */
        public ApiResponse<SmsDto> executeWithHttpInfo() throws ApiException {
            return waitForLatestSmsWithHttpInfo(waitForSingleSmsOptions);
        }

        /**
         * Execute waitForLatestSms request (asynchronously)
         * @param _callback The callback to be executed when the API call finishes
         * @return The request call
         * @throws ApiException If fail to process the API call, e.g. serializing the request body object
         * @http.response.details
         <table border="1">
       <caption>Response Details</caption>
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
         </table>
         */
        public okhttp3.Call executeAsync(final ApiCallback<SmsDto> _callback) throws ApiException {
            return waitForLatestSmsAsync(waitForSingleSmsOptions, _callback);
        }
    }

    /**
     * Wait for the latest SMS message to match the provided filter conditions such as body contains keyword.
     * Wait until a phone number meets given conditions or return immediately if already met
     * @param waitForSingleSmsOptions  (required)
     * @return APIwaitForLatestSmsRequest
     * @http.response.details
     <table border="1">
       <caption>Response Details</caption>
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
     </table>
     */
    public APIwaitForLatestSmsRequest waitForLatestSms(@javax.annotation.Nonnull WaitForSingleSmsOptions waitForSingleSmsOptions) {
        return new APIwaitForLatestSmsRequest(waitForSingleSmsOptions);
    }
    private okhttp3.Call waitForMatchingEmailsCall(@javax.annotation.Nonnull UUID inboxId, @javax.annotation.Nonnull Integer count, @javax.annotation.Nonnull MatchOptions matchOptions, @javax.annotation.Nullable OffsetDateTime before, @javax.annotation.Nullable OffsetDateTime since, @javax.annotation.Nullable String sort, @javax.annotation.Nullable Long delay, @javax.annotation.Nullable Long timeout, @javax.annotation.Nullable Boolean unreadOnly, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = matchOptions;

        // create path and map variables
        String localVarPath = "/waitForMatchingEmails";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (inboxId != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("inboxId", inboxId));
        }

        if (count != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("count", count));
        }

        if (before != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("before", before));
        }

        if (since != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("since", since));
        }

        if (sort != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("sort", sort));
        }

        if (delay != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("delay", delay));
        }

        if (timeout != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("timeout", timeout));
        }

        if (unreadOnly != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("unreadOnly", unreadOnly));
        }

        final String[] localVarAccepts = {
            "*/*"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
            "application/json"
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "API_KEY" };
        return localVarApiClient.buildCall(basePath, localVarPath, "POST", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call waitForMatchingEmailsValidateBeforeCall(@javax.annotation.Nonnull UUID inboxId, @javax.annotation.Nonnull Integer count, @javax.annotation.Nonnull MatchOptions matchOptions, @javax.annotation.Nullable OffsetDateTime before, @javax.annotation.Nullable OffsetDateTime since, @javax.annotation.Nullable String sort, @javax.annotation.Nullable Long delay, @javax.annotation.Nullable Long timeout, @javax.annotation.Nullable Boolean unreadOnly, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'inboxId' is set
        if (inboxId == null) {
            throw new ApiException("Missing the required parameter 'inboxId' when calling waitForMatchingEmails(Async)");
        }

        // verify the required parameter 'count' is set
        if (count == null) {
            throw new ApiException("Missing the required parameter 'count' when calling waitForMatchingEmails(Async)");
        }

        // verify the required parameter 'matchOptions' is set
        if (matchOptions == null) {
            throw new ApiException("Missing the required parameter 'matchOptions' when calling waitForMatchingEmails(Async)");
        }

        return waitForMatchingEmailsCall(inboxId, count, matchOptions, before, since, sort, delay, timeout, unreadOnly, _callback);

    }


    private ApiResponse<List<EmailPreview>> waitForMatchingEmailsWithHttpInfo(@javax.annotation.Nonnull UUID inboxId, @javax.annotation.Nonnull Integer count, @javax.annotation.Nonnull MatchOptions matchOptions, @javax.annotation.Nullable OffsetDateTime before, @javax.annotation.Nullable OffsetDateTime since, @javax.annotation.Nullable String sort, @javax.annotation.Nullable Long delay, @javax.annotation.Nullable Long timeout, @javax.annotation.Nullable Boolean unreadOnly) throws ApiException {
        okhttp3.Call localVarCall = waitForMatchingEmailsValidateBeforeCall(inboxId, count, matchOptions, before, since, sort, delay, timeout, unreadOnly, null);
        Type localVarReturnType = new TypeToken<List<EmailPreview>>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    private okhttp3.Call waitForMatchingEmailsAsync(@javax.annotation.Nonnull UUID inboxId, @javax.annotation.Nonnull Integer count, @javax.annotation.Nonnull MatchOptions matchOptions, @javax.annotation.Nullable OffsetDateTime before, @javax.annotation.Nullable OffsetDateTime since, @javax.annotation.Nullable String sort, @javax.annotation.Nullable Long delay, @javax.annotation.Nullable Long timeout, @javax.annotation.Nullable Boolean unreadOnly, final ApiCallback<List<EmailPreview>> _callback) throws ApiException {

        okhttp3.Call localVarCall = waitForMatchingEmailsValidateBeforeCall(inboxId, count, matchOptions, before, since, sort, delay, timeout, unreadOnly, _callback);
        Type localVarReturnType = new TypeToken<List<EmailPreview>>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }

    public class APIwaitForMatchingEmailsRequest {
        @javax.annotation.Nonnull
        private final UUID inboxId;
        @javax.annotation.Nonnull
        private final Integer count;
        @javax.annotation.Nonnull
        private final MatchOptions matchOptions;
        @javax.annotation.Nullable
        private OffsetDateTime before;
        @javax.annotation.Nullable
        private OffsetDateTime since;
        @javax.annotation.Nullable
        private String sort;
        @javax.annotation.Nullable
        private Long delay;
        @javax.annotation.Nullable
        private Long timeout;
        @javax.annotation.Nullable
        private Boolean unreadOnly;

        private APIwaitForMatchingEmailsRequest(@javax.annotation.Nonnull UUID inboxId, @javax.annotation.Nonnull Integer count, @javax.annotation.Nonnull MatchOptions matchOptions) {
            this.inboxId = inboxId;
            this.count = count;
            this.matchOptions = matchOptions;
        }

        /**
         * Set before
         * @param before Filter for emails that were received before the given timestamp (optional)
         * @return APIwaitForMatchingEmailsRequest
         */
        public APIwaitForMatchingEmailsRequest before(@javax.annotation.Nullable OffsetDateTime before) {
            this.before = before;
            return this;
        }

        /**
         * Set since
         * @param since Filter for emails that were received after the given timestamp (optional)
         * @return APIwaitForMatchingEmailsRequest
         */
        public APIwaitForMatchingEmailsRequest since(@javax.annotation.Nullable OffsetDateTime since) {
            this.since = since;
            return this;
        }

        /**
         * Set sort
         * @param sort Sort direction (optional)
         * @return APIwaitForMatchingEmailsRequest
         */
        public APIwaitForMatchingEmailsRequest sort(@javax.annotation.Nullable String sort) {
            this.sort = sort;
            return this;
        }

        /**
         * Set delay
         * @param delay Max milliseconds delay between calls (optional)
         * @return APIwaitForMatchingEmailsRequest
         */
        public APIwaitForMatchingEmailsRequest delay(@javax.annotation.Nullable Long delay) {
            this.delay = delay;
            return this;
        }

        /**
         * Set timeout
         * @param timeout Max milliseconds to wait (optional)
         * @return APIwaitForMatchingEmailsRequest
         */
        public APIwaitForMatchingEmailsRequest timeout(@javax.annotation.Nullable Long timeout) {
            this.timeout = timeout;
            return this;
        }

        /**
         * Set unreadOnly
         * @param unreadOnly Optional filter for unread only (optional, default to false)
         * @return APIwaitForMatchingEmailsRequest
         */
        public APIwaitForMatchingEmailsRequest unreadOnly(@javax.annotation.Nullable Boolean unreadOnly) {
            this.unreadOnly = unreadOnly;
            return this;
        }

        /**
         * Build call for waitForMatchingEmails
         * @param _callback ApiCallback API callback
         * @return Call to execute
         * @throws ApiException If fail to serialize the request body object
         * @http.response.details
         <table border="1">
       <caption>Response Details</caption>
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
         </table>
         */
        public okhttp3.Call buildCall(final ApiCallback _callback) throws ApiException {
            return waitForMatchingEmailsCall(inboxId, count, matchOptions, before, since, sort, delay, timeout, unreadOnly, _callback);
        }

        /**
         * Execute waitForMatchingEmails request
         * @return List&lt;EmailPreview&gt;
         * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
         * @http.response.details
         <table border="1">
       <caption>Response Details</caption>
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
         </table>
         */
        public List<EmailPreview> execute() throws ApiException {
            ApiResponse<List<EmailPreview>> localVarResp = waitForMatchingEmailsWithHttpInfo(inboxId, count, matchOptions, before, since, sort, delay, timeout, unreadOnly);
            return localVarResp.getData();
        }

        /**
         * Execute waitForMatchingEmails request with HTTP info returned
         * @return ApiResponse&lt;List&lt;EmailPreview&gt;&gt;
         * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
         * @http.response.details
         <table border="1">
       <caption>Response Details</caption>
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
         </table>
         */
        public ApiResponse<List<EmailPreview>> executeWithHttpInfo() throws ApiException {
            return waitForMatchingEmailsWithHttpInfo(inboxId, count, matchOptions, before, since, sort, delay, timeout, unreadOnly);
        }

        /**
         * Execute waitForMatchingEmails request (asynchronously)
         * @param _callback The callback to be executed when the API call finishes
         * @return The request call
         * @throws ApiException If fail to process the API call, e.g. serializing the request body object
         * @http.response.details
         <table border="1">
       <caption>Response Details</caption>
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
         </table>
         */
        public okhttp3.Call executeAsync(final ApiCallback<List<EmailPreview>> _callback) throws ApiException {
            return waitForMatchingEmailsAsync(inboxId, count, matchOptions, before, since, sort, delay, timeout, unreadOnly, _callback);
        }
    }

    /**
     * Wait or return list of emails that match simple matching patterns
     * Perform a search of emails in an inbox with the given patterns. If results match expected count then return or else retry the search until results are found or timeout is reached. Match options allow simple CONTAINS or EQUALS filtering on SUBJECT, TO, BCC, CC, and FROM. See the &#x60;MatchOptions&#x60; object for options. An example payload is &#x60;{ matches: [{field: &#39;SUBJECT&#39;,should:&#39;CONTAIN&#39;,value:&#39;needle&#39;}] }&#x60;. You can use an array of matches and they will be applied sequentially to filter out emails. If you want to perform matches and extractions of content using Regex patterns see the EmailController &#x60;getEmailContentMatch&#x60; method.
     * @param inboxId Id of the inbox we are fetching emails from (required)
     * @param count Number of emails to wait for. Must be greater or equal to 1 (required)
     * @param matchOptions  (required)
     * @return APIwaitForMatchingEmailsRequest
     * @http.response.details
     <table border="1">
       <caption>Response Details</caption>
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
     </table>
     */
    public APIwaitForMatchingEmailsRequest waitForMatchingEmails(@javax.annotation.Nonnull UUID inboxId, @javax.annotation.Nonnull Integer count, @javax.annotation.Nonnull MatchOptions matchOptions) {
        return new APIwaitForMatchingEmailsRequest(inboxId, count, matchOptions);
    }
    private okhttp3.Call waitForMatchingFirstEmailCall(@javax.annotation.Nonnull UUID inboxId, @javax.annotation.Nonnull MatchOptions matchOptions, @javax.annotation.Nullable Long timeout, @javax.annotation.Nullable Boolean unreadOnly, @javax.annotation.Nullable OffsetDateTime since, @javax.annotation.Nullable OffsetDateTime before, @javax.annotation.Nullable String sort, @javax.annotation.Nullable Long delay, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = matchOptions;

        // create path and map variables
        String localVarPath = "/waitForMatchingFirstEmail";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (inboxId != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("inboxId", inboxId));
        }

        if (timeout != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("timeout", timeout));
        }

        if (unreadOnly != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("unreadOnly", unreadOnly));
        }

        if (since != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("since", since));
        }

        if (before != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("before", before));
        }

        if (sort != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("sort", sort));
        }

        if (delay != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("delay", delay));
        }

        final String[] localVarAccepts = {
            "*/*"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
            "application/json"
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "API_KEY" };
        return localVarApiClient.buildCall(basePath, localVarPath, "POST", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call waitForMatchingFirstEmailValidateBeforeCall(@javax.annotation.Nonnull UUID inboxId, @javax.annotation.Nonnull MatchOptions matchOptions, @javax.annotation.Nullable Long timeout, @javax.annotation.Nullable Boolean unreadOnly, @javax.annotation.Nullable OffsetDateTime since, @javax.annotation.Nullable OffsetDateTime before, @javax.annotation.Nullable String sort, @javax.annotation.Nullable Long delay, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'inboxId' is set
        if (inboxId == null) {
            throw new ApiException("Missing the required parameter 'inboxId' when calling waitForMatchingFirstEmail(Async)");
        }

        // verify the required parameter 'matchOptions' is set
        if (matchOptions == null) {
            throw new ApiException("Missing the required parameter 'matchOptions' when calling waitForMatchingFirstEmail(Async)");
        }

        return waitForMatchingFirstEmailCall(inboxId, matchOptions, timeout, unreadOnly, since, before, sort, delay, _callback);

    }


    private ApiResponse<Email> waitForMatchingFirstEmailWithHttpInfo(@javax.annotation.Nonnull UUID inboxId, @javax.annotation.Nonnull MatchOptions matchOptions, @javax.annotation.Nullable Long timeout, @javax.annotation.Nullable Boolean unreadOnly, @javax.annotation.Nullable OffsetDateTime since, @javax.annotation.Nullable OffsetDateTime before, @javax.annotation.Nullable String sort, @javax.annotation.Nullable Long delay) throws ApiException {
        okhttp3.Call localVarCall = waitForMatchingFirstEmailValidateBeforeCall(inboxId, matchOptions, timeout, unreadOnly, since, before, sort, delay, null);
        Type localVarReturnType = new TypeToken<Email>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    private okhttp3.Call waitForMatchingFirstEmailAsync(@javax.annotation.Nonnull UUID inboxId, @javax.annotation.Nonnull MatchOptions matchOptions, @javax.annotation.Nullable Long timeout, @javax.annotation.Nullable Boolean unreadOnly, @javax.annotation.Nullable OffsetDateTime since, @javax.annotation.Nullable OffsetDateTime before, @javax.annotation.Nullable String sort, @javax.annotation.Nullable Long delay, final ApiCallback<Email> _callback) throws ApiException {

        okhttp3.Call localVarCall = waitForMatchingFirstEmailValidateBeforeCall(inboxId, matchOptions, timeout, unreadOnly, since, before, sort, delay, _callback);
        Type localVarReturnType = new TypeToken<Email>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }

    public class APIwaitForMatchingFirstEmailRequest {
        @javax.annotation.Nonnull
        private final UUID inboxId;
        @javax.annotation.Nonnull
        private final MatchOptions matchOptions;
        @javax.annotation.Nullable
        private Long timeout;
        @javax.annotation.Nullable
        private Boolean unreadOnly;
        @javax.annotation.Nullable
        private OffsetDateTime since;
        @javax.annotation.Nullable
        private OffsetDateTime before;
        @javax.annotation.Nullable
        private String sort;
        @javax.annotation.Nullable
        private Long delay;

        private APIwaitForMatchingFirstEmailRequest(@javax.annotation.Nonnull UUID inboxId, @javax.annotation.Nonnull MatchOptions matchOptions) {
            this.inboxId = inboxId;
            this.matchOptions = matchOptions;
        }

        /**
         * Set timeout
         * @param timeout Max milliseconds to wait (optional)
         * @return APIwaitForMatchingFirstEmailRequest
         */
        public APIwaitForMatchingFirstEmailRequest timeout(@javax.annotation.Nullable Long timeout) {
            this.timeout = timeout;
            return this;
        }

        /**
         * Set unreadOnly
         * @param unreadOnly Optional filter for unread only (optional, default to false)
         * @return APIwaitForMatchingFirstEmailRequest
         */
        public APIwaitForMatchingFirstEmailRequest unreadOnly(@javax.annotation.Nullable Boolean unreadOnly) {
            this.unreadOnly = unreadOnly;
            return this;
        }

        /**
         * Set since
         * @param since Filter for emails that were received after the given timestamp (optional)
         * @return APIwaitForMatchingFirstEmailRequest
         */
        public APIwaitForMatchingFirstEmailRequest since(@javax.annotation.Nullable OffsetDateTime since) {
            this.since = since;
            return this;
        }

        /**
         * Set before
         * @param before Filter for emails that were received before the given timestamp (optional)
         * @return APIwaitForMatchingFirstEmailRequest
         */
        public APIwaitForMatchingFirstEmailRequest before(@javax.annotation.Nullable OffsetDateTime before) {
            this.before = before;
            return this;
        }

        /**
         * Set sort
         * @param sort Sort direction (optional)
         * @return APIwaitForMatchingFirstEmailRequest
         */
        public APIwaitForMatchingFirstEmailRequest sort(@javax.annotation.Nullable String sort) {
            this.sort = sort;
            return this;
        }

        /**
         * Set delay
         * @param delay Max milliseconds delay between calls (optional)
         * @return APIwaitForMatchingFirstEmailRequest
         */
        public APIwaitForMatchingFirstEmailRequest delay(@javax.annotation.Nullable Long delay) {
            this.delay = delay;
            return this;
        }

        /**
         * Build call for waitForMatchingFirstEmail
         * @param _callback ApiCallback API callback
         * @return Call to execute
         * @throws ApiException If fail to serialize the request body object
         * @http.response.details
         <table border="1">
       <caption>Response Details</caption>
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
         </table>
         */
        public okhttp3.Call buildCall(final ApiCallback _callback) throws ApiException {
            return waitForMatchingFirstEmailCall(inboxId, matchOptions, timeout, unreadOnly, since, before, sort, delay, _callback);
        }

        /**
         * Execute waitForMatchingFirstEmail request
         * @return Email
         * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
         * @http.response.details
         <table border="1">
       <caption>Response Details</caption>
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
         </table>
         */
        public Email execute() throws ApiException {
            ApiResponse<Email> localVarResp = waitForMatchingFirstEmailWithHttpInfo(inboxId, matchOptions, timeout, unreadOnly, since, before, sort, delay);
            return localVarResp.getData();
        }

        /**
         * Execute waitForMatchingFirstEmail request with HTTP info returned
         * @return ApiResponse&lt;Email&gt;
         * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
         * @http.response.details
         <table border="1">
       <caption>Response Details</caption>
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
         </table>
         */
        public ApiResponse<Email> executeWithHttpInfo() throws ApiException {
            return waitForMatchingFirstEmailWithHttpInfo(inboxId, matchOptions, timeout, unreadOnly, since, before, sort, delay);
        }

        /**
         * Execute waitForMatchingFirstEmail request (asynchronously)
         * @param _callback The callback to be executed when the API call finishes
         * @return The request call
         * @throws ApiException If fail to process the API call, e.g. serializing the request body object
         * @http.response.details
         <table border="1">
       <caption>Response Details</caption>
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
         </table>
         */
        public okhttp3.Call executeAsync(final ApiCallback<Email> _callback) throws ApiException {
            return waitForMatchingFirstEmailAsync(inboxId, matchOptions, timeout, unreadOnly, since, before, sort, delay, _callback);
        }
    }

    /**
     * Wait for or return the first email that matches provided MatchOptions array
     * Perform a search of emails in an inbox with the given patterns. If a result if found then return or else retry the search until a result is found or timeout is reached. Match options allow simple CONTAINS or EQUALS filtering on SUBJECT, TO, BCC, CC, and FROM. See the &#x60;MatchOptions&#x60; object for options. An example payload is &#x60;{ matches: [{field: &#39;SUBJECT&#39;,should:&#39;CONTAIN&#39;,value:&#39;needle&#39;}] }&#x60;. You can use an array of matches and they will be applied sequentially to filter out emails. If you want to perform matches and extractions of content using Regex patterns see the EmailController &#x60;getEmailContentMatch&#x60; method.
     * @param inboxId Id of the inbox we are matching an email for (required)
     * @param matchOptions  (required)
     * @return APIwaitForMatchingFirstEmailRequest
     * @http.response.details
     <table border="1">
       <caption>Response Details</caption>
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
     </table>
     */
    public APIwaitForMatchingFirstEmailRequest waitForMatchingFirstEmail(@javax.annotation.Nonnull UUID inboxId, @javax.annotation.Nonnull MatchOptions matchOptions) {
        return new APIwaitForMatchingFirstEmailRequest(inboxId, matchOptions);
    }
    private okhttp3.Call waitForNthEmailCall(@javax.annotation.Nullable UUID inboxId, @javax.annotation.Nullable Integer index, @javax.annotation.Nullable Long timeout, @javax.annotation.Nullable Boolean unreadOnly, @javax.annotation.Nullable OffsetDateTime since, @javax.annotation.Nullable OffsetDateTime before, @javax.annotation.Nullable String sort, @javax.annotation.Nullable Long delay, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/waitForNthEmail";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (inboxId != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("inboxId", inboxId));
        }

        if (index != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("index", index));
        }

        if (timeout != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("timeout", timeout));
        }

        if (unreadOnly != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("unreadOnly", unreadOnly));
        }

        if (since != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("since", since));
        }

        if (before != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("before", before));
        }

        if (sort != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("sort", sort));
        }

        if (delay != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("delay", delay));
        }

        final String[] localVarAccepts = {
            "*/*"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "API_KEY" };
        return localVarApiClient.buildCall(basePath, localVarPath, "GET", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call waitForNthEmailValidateBeforeCall(@javax.annotation.Nullable UUID inboxId, @javax.annotation.Nullable Integer index, @javax.annotation.Nullable Long timeout, @javax.annotation.Nullable Boolean unreadOnly, @javax.annotation.Nullable OffsetDateTime since, @javax.annotation.Nullable OffsetDateTime before, @javax.annotation.Nullable String sort, @javax.annotation.Nullable Long delay, final ApiCallback _callback) throws ApiException {
        return waitForNthEmailCall(inboxId, index, timeout, unreadOnly, since, before, sort, delay, _callback);

    }


    private ApiResponse<Email> waitForNthEmailWithHttpInfo(@javax.annotation.Nullable UUID inboxId, @javax.annotation.Nullable Integer index, @javax.annotation.Nullable Long timeout, @javax.annotation.Nullable Boolean unreadOnly, @javax.annotation.Nullable OffsetDateTime since, @javax.annotation.Nullable OffsetDateTime before, @javax.annotation.Nullable String sort, @javax.annotation.Nullable Long delay) throws ApiException {
        okhttp3.Call localVarCall = waitForNthEmailValidateBeforeCall(inboxId, index, timeout, unreadOnly, since, before, sort, delay, null);
        Type localVarReturnType = new TypeToken<Email>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    private okhttp3.Call waitForNthEmailAsync(@javax.annotation.Nullable UUID inboxId, @javax.annotation.Nullable Integer index, @javax.annotation.Nullable Long timeout, @javax.annotation.Nullable Boolean unreadOnly, @javax.annotation.Nullable OffsetDateTime since, @javax.annotation.Nullable OffsetDateTime before, @javax.annotation.Nullable String sort, @javax.annotation.Nullable Long delay, final ApiCallback<Email> _callback) throws ApiException {

        okhttp3.Call localVarCall = waitForNthEmailValidateBeforeCall(inboxId, index, timeout, unreadOnly, since, before, sort, delay, _callback);
        Type localVarReturnType = new TypeToken<Email>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }

    public class APIwaitForNthEmailRequest {
        @javax.annotation.Nullable
        private UUID inboxId;
        @javax.annotation.Nullable
        private Integer index;
        @javax.annotation.Nullable
        private Long timeout;
        @javax.annotation.Nullable
        private Boolean unreadOnly;
        @javax.annotation.Nullable
        private OffsetDateTime since;
        @javax.annotation.Nullable
        private OffsetDateTime before;
        @javax.annotation.Nullable
        private String sort;
        @javax.annotation.Nullable
        private Long delay;

        private APIwaitForNthEmailRequest() {
        }

        /**
         * Set inboxId
         * @param inboxId Id of the inbox you are fetching emails from (optional)
         * @return APIwaitForNthEmailRequest
         */
        public APIwaitForNthEmailRequest inboxId(@javax.annotation.Nullable UUID inboxId) {
            this.inboxId = inboxId;
            return this;
        }

        /**
         * Set index
         * @param index Zero based index of the email to wait for. If an inbox has 1 email already and you want to wait for the 2nd email pass index&#x3D;1 (optional, default to 0)
         * @return APIwaitForNthEmailRequest
         */
        public APIwaitForNthEmailRequest index(@javax.annotation.Nullable Integer index) {
            this.index = index;
            return this;
        }

        /**
         * Set timeout
         * @param timeout Max milliseconds to wait for the nth email if not already present (optional)
         * @return APIwaitForNthEmailRequest
         */
        public APIwaitForNthEmailRequest timeout(@javax.annotation.Nullable Long timeout) {
            this.timeout = timeout;
            return this;
        }

        /**
         * Set unreadOnly
         * @param unreadOnly Optional filter for unread only (optional, default to false)
         * @return APIwaitForNthEmailRequest
         */
        public APIwaitForNthEmailRequest unreadOnly(@javax.annotation.Nullable Boolean unreadOnly) {
            this.unreadOnly = unreadOnly;
            return this;
        }

        /**
         * Set since
         * @param since Filter for emails that were received after the given timestamp (optional)
         * @return APIwaitForNthEmailRequest
         */
        public APIwaitForNthEmailRequest since(@javax.annotation.Nullable OffsetDateTime since) {
            this.since = since;
            return this;
        }

        /**
         * Set before
         * @param before Filter for emails that were received before the given timestamp (optional)
         * @return APIwaitForNthEmailRequest
         */
        public APIwaitForNthEmailRequest before(@javax.annotation.Nullable OffsetDateTime before) {
            this.before = before;
            return this;
        }

        /**
         * Set sort
         * @param sort Sort direction (optional)
         * @return APIwaitForNthEmailRequest
         */
        public APIwaitForNthEmailRequest sort(@javax.annotation.Nullable String sort) {
            this.sort = sort;
            return this;
        }

        /**
         * Set delay
         * @param delay Max milliseconds delay between calls (optional)
         * @return APIwaitForNthEmailRequest
         */
        public APIwaitForNthEmailRequest delay(@javax.annotation.Nullable Long delay) {
            this.delay = delay;
            return this;
        }

        /**
         * Build call for waitForNthEmail
         * @param _callback ApiCallback API callback
         * @return Call to execute
         * @throws ApiException If fail to serialize the request body object
         * @http.response.details
         <table border="1">
       <caption>Response Details</caption>
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
         </table>
         */
        public okhttp3.Call buildCall(final ApiCallback _callback) throws ApiException {
            return waitForNthEmailCall(inboxId, index, timeout, unreadOnly, since, before, sort, delay, _callback);
        }

        /**
         * Execute waitForNthEmail request
         * @return Email
         * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
         * @http.response.details
         <table border="1">
       <caption>Response Details</caption>
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
         </table>
         */
        public Email execute() throws ApiException {
            ApiResponse<Email> localVarResp = waitForNthEmailWithHttpInfo(inboxId, index, timeout, unreadOnly, since, before, sort, delay);
            return localVarResp.getData();
        }

        /**
         * Execute waitForNthEmail request with HTTP info returned
         * @return ApiResponse&lt;Email&gt;
         * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
         * @http.response.details
         <table border="1">
       <caption>Response Details</caption>
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
         </table>
         */
        public ApiResponse<Email> executeWithHttpInfo() throws ApiException {
            return waitForNthEmailWithHttpInfo(inboxId, index, timeout, unreadOnly, since, before, sort, delay);
        }

        /**
         * Execute waitForNthEmail request (asynchronously)
         * @param _callback The callback to be executed when the API call finishes
         * @return The request call
         * @throws ApiException If fail to process the API call, e.g. serializing the request body object
         * @http.response.details
         <table border="1">
       <caption>Response Details</caption>
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
         </table>
         */
        public okhttp3.Call executeAsync(final ApiCallback<Email> _callback) throws ApiException {
            return waitForNthEmailAsync(inboxId, index, timeout, unreadOnly, since, before, sort, delay, _callback);
        }
    }

    /**
     * Wait for or fetch the email with a given index in the inbox specified. If index doesn&#39;t exist waits for it to exist or timeout to occur.
     * If nth email is already present in inbox then return it. If not hold the connection open until timeout expires or the nth email is received and returned.
     * @return APIwaitForNthEmailRequest
     * @http.response.details
     <table border="1">
       <caption>Response Details</caption>
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
     </table>
     */
    public APIwaitForNthEmailRequest waitForNthEmail() {
        return new APIwaitForNthEmailRequest();
    }
    private okhttp3.Call waitForSmsCall(@javax.annotation.Nonnull WaitForSmsConditions waitForSmsConditions, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = waitForSmsConditions;

        // create path and map variables
        String localVarPath = "/waitForSms";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {
            "*/*"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
            "application/json"
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "API_KEY" };
        return localVarApiClient.buildCall(basePath, localVarPath, "POST", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call waitForSmsValidateBeforeCall(@javax.annotation.Nonnull WaitForSmsConditions waitForSmsConditions, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'waitForSmsConditions' is set
        if (waitForSmsConditions == null) {
            throw new ApiException("Missing the required parameter 'waitForSmsConditions' when calling waitForSms(Async)");
        }

        return waitForSmsCall(waitForSmsConditions, _callback);

    }


    private ApiResponse<List<SmsPreview>> waitForSmsWithHttpInfo(@javax.annotation.Nonnull WaitForSmsConditions waitForSmsConditions) throws ApiException {
        okhttp3.Call localVarCall = waitForSmsValidateBeforeCall(waitForSmsConditions, null);
        Type localVarReturnType = new TypeToken<List<SmsPreview>>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    private okhttp3.Call waitForSmsAsync(@javax.annotation.Nonnull WaitForSmsConditions waitForSmsConditions, final ApiCallback<List<SmsPreview>> _callback) throws ApiException {

        okhttp3.Call localVarCall = waitForSmsValidateBeforeCall(waitForSmsConditions, _callback);
        Type localVarReturnType = new TypeToken<List<SmsPreview>>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }

    public class APIwaitForSmsRequest {
        @javax.annotation.Nonnull
        private final WaitForSmsConditions waitForSmsConditions;

        private APIwaitForSmsRequest(@javax.annotation.Nonnull WaitForSmsConditions waitForSmsConditions) {
            this.waitForSmsConditions = waitForSmsConditions;
        }

        /**
         * Build call for waitForSms
         * @param _callback ApiCallback API callback
         * @return Call to execute
         * @throws ApiException If fail to serialize the request body object
         * @http.response.details
         <table border="1">
       <caption>Response Details</caption>
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
         </table>
         */
        public okhttp3.Call buildCall(final ApiCallback _callback) throws ApiException {
            return waitForSmsCall(waitForSmsConditions, _callback);
        }

        /**
         * Execute waitForSms request
         * @return List&lt;SmsPreview&gt;
         * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
         * @http.response.details
         <table border="1">
       <caption>Response Details</caption>
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
         </table>
         */
        public List<SmsPreview> execute() throws ApiException {
            ApiResponse<List<SmsPreview>> localVarResp = waitForSmsWithHttpInfo(waitForSmsConditions);
            return localVarResp.getData();
        }

        /**
         * Execute waitForSms request with HTTP info returned
         * @return ApiResponse&lt;List&lt;SmsPreview&gt;&gt;
         * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
         * @http.response.details
         <table border="1">
       <caption>Response Details</caption>
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
         </table>
         */
        public ApiResponse<List<SmsPreview>> executeWithHttpInfo() throws ApiException {
            return waitForSmsWithHttpInfo(waitForSmsConditions);
        }

        /**
         * Execute waitForSms request (asynchronously)
         * @param _callback The callback to be executed when the API call finishes
         * @return The request call
         * @throws ApiException If fail to process the API call, e.g. serializing the request body object
         * @http.response.details
         <table border="1">
       <caption>Response Details</caption>
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
         </table>
         */
        public okhttp3.Call executeAsync(final ApiCallback<List<SmsPreview>> _callback) throws ApiException {
            return waitForSmsAsync(waitForSmsConditions, _callback);
        }
    }

    /**
     * Wait for an SMS message to match the provided filter conditions such as body contains keyword.
     * Generic waitFor method that will wait until a phone number meets given conditions or return immediately if already met
     * @param waitForSmsConditions  (required)
     * @return APIwaitForSmsRequest
     * @http.response.details
     <table border="1">
       <caption>Response Details</caption>
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
     </table>
     */
    public APIwaitForSmsRequest waitForSms(@javax.annotation.Nonnull WaitForSmsConditions waitForSmsConditions) {
        return new APIwaitForSmsRequest(waitForSmsConditions);
    }
}
